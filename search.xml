<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>üëìEnumination</title>
    <url>/2025/02/18/article-1/</url>
    <content><![CDATA[<h1 id="the-main-idea-of-enumeration-algorithm">1. The main idea of
enumeration algorithm</h1>
<blockquote>
<p>‚ÄúList all possible solutions to this problem one by one, and in the
process of listing, check each possible solution to see if it is the
true solution to the problem.‚Äù</p>
</blockquote>
<span id="more"></span>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a>
<strong>Instruction:</strong></p>
<ol type="1">
<li><p><strong>Identify the enumeration objects</strong></p></li>
<li><p><strong>List possible solutions one by one</strong></p></li>
<li><p><strong>Verify each possible solution one by
one</strong></p></li>
</ol>
<h1 id="typical-application-examples-of-enumeration-algorithm">2.
Typical application examples of enumeration algorithm</h1>
<h2 id="array-paring">2.1 Array paring</h2>
<hr />
<h3 id="problem-description">2.1.1 <strong>Problem
Description</strong></h3>
<p>The problem presented involves selecting two distinct numbers from an
array of size n such that their sum is divisible by a given integer
<span class="math inline">\(k\)</span>. The challenge is to calculate
how many different pairs can be chosen, while considering that pairs
like <span class="math inline">\((a_1, a_2)\)</span> and <span
class="math inline">\((a_2, a_1)\)</span> are considered the same.</p>
<p>Given:</p>
<ul>
<li><p>An array <span class="math inline">\(A\)</span> of length <span
class="math inline">\(n\)</span>.</p></li>
<li><p>A positive integer <span
class="math inline">\(k\)</span>.</p></li>
<li><p>The task is to select pairs of numbers <span
class="math inline">\(a_i\)</span> and <span
class="math inline">\(a_j\)</span> (where <span class="math inline">\(i
&lt; j\)</span>) such that:</p>
<p><span class="math inline">\((a_i + a_j) \% k = 0\)</span></p></li>
</ul>
<p>Where <span class="math inline">\(a_i\)</span> and <span
class="math inline">\(a_j\)</span> are two numbers chosen from the
array.</p>
<h3 id="algorithm-and-approach">2.1.2 <strong>Algorithm and
Approach</strong></h3>
<ol type="1">
<li><p><strong>Brute Force Enumeration</strong>: The brute force
approach would involve looping through all possible pairs of numbers in
the array and checking whether their sum is divisible by <span
class="math inline">\(k\)</span>. This approach has a time complexity of
<span class="math inline">\(O(n^2)\)</span>, where <span
class="math inline">\(n\)</span> is the size of the array. For large
values of <span class="math inline">\(n\)</span>, this results in <span
class="math inline">\(O(10^{12})\)</span> operations, which is
computationally expensive.</p></li>
<li><p><strong>Optimization with Remainder Buckets</strong>: The key
observation is to use modulo arithmetic. If we can categorize the
numbers by their remainders when divided by k, then we can use this to
reduce the complexity. <span class="math inline">\(B_0\)</span> for
numbers where <span class="math inline">\(a_i \% k = 0\)</span> ; <span
class="math inline">\(B_1\)</span> for numbers where <span
class="math inline">\(a_i \% k = 1\)</span>‚Ä¶</p>
<p><strong>Pair Counting Function:</strong> if <span
class="math inline">\((i + j) \% k = 0\)</span> and <span
class="math inline">\(i‚â†j\)</span> : <span
class="math inline">\(\text{count}(B_i) \times
\text{count}(B_j)\)</span> if <span class="math inline">\(i=j\)</span> :
<span class="math inline">\(\frac{\text{count}(B_i) \times
(\text{count}(B_i) - 1)}{2}\)</span></p></li>
<li><p><strong>Time Complexity:</strong> The time complexity of this
optimized solution is <span class="math inline">\(O(n + k)\)</span> , as
we only need to iterate through the array once to categorize the
numbers, and then we iterate through the <span
class="math inline">\(k\)</span> buckets to count pairs.</p></li>
</ol>
<h3 id="code-example">2.1.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>]; <span class="comment">// Array to count numbers in remainder buckets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// Reset the array</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[t % k]++; <span class="comment">// Count numbers by remainder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (k - i) % k;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="keyword">break</span>; <span class="comment">// Avoid counting the same pairs twice</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == j) ans += <span class="number">1LL</span> * a[i] * (a[i] - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// Special case for same remainder</span></span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">1LL</span> * a[i] * a[j]; <span class="comment">// Count valid pairs from different remainder groups</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stone-removal">2.2 <strong>Stone Removal</strong></h2>
<h3 id="problem-description-1">2.2.1 <strong>Problem
Description</strong></h3>
<p>In this problem, we are given a river with stones arranged along its
length, and the goal is to remove some stones such that the remaining
stones have a minimal distance between two consecutive stones. The task
is to remove a maximum of <span class="math inline">\(m\)</span> stones
and maximize the minimum distance between the remaining consecutive
stones.</p>
<p>Given:</p>
<ul>
<li>A sequence of stones represented as an array <span
class="math inline">\(S = [s_1, s_2, \dots, s_n]\)</span> , where the
distance between two consecutive stones is provided.</li>
<li>A positive integer <span class="math inline">\(m\)</span> , which
represents the maximum number of stones that can be removed.</li>
<li>The objective is to determine the maximum minimum distance between
consecutive stones after removing up to <span
class="math inline">\(m\)</span> stones.</li>
</ul>
<p>Input:</p>
<p>The input consists of multiple test cases (up to 20).</p>
<p>Each test case consists of two integers:</p>
<ul>
<li><span class="math inline">\(n\)</span> (<span
class="math inline">\(2 ‚â§\)</span> <span
class="math inline">\(n\)</span> <span class="math inline">\(‚â§
1000\)</span>), representing the number of stones.</li>
<li><span class="math inline">\(m\)</span> (<span
class="math inline">\(0 ‚â§  m \leq n-2\)</span> ), the maximum number of
stones that can be removed.</li>
<li>Then follow <span class="math inline">\(n-1\)</span> integers
representing the distances between adjacent stones.</li>
</ul>
<p>Output:</p>
<p>For each test case, output the maximum possible minimum distance
between any two consecutive stones after removing up to <span
class="math inline">\(m\)</span> stones.</p>
<h3 id="algorithm-and-approach-1">2.2.2 <strong>Algorithm and
Approach</strong></h3>
<ol type="1">
<li><strong>Validate Function</strong>¬† <span
class="math inline">\(C(d)\)</span> : The function <span
class="math inline">\(C(d)\)</span> checks if we can maintain a minimum
distance of <span class="math inline">\(d\)</span> after removing up to
m stones. We start with the first stone and try to place the subsequent
stones such that their distance from the last placed stone is at least
<span class="math inline">\(d\)</span> .</li>
<li><strong>Binary Search Optimization</strong>:¬†Since <span
class="math inline">\(C(d)\)</span> is a monotonic function (if a
distance <span class="math inline">\(d\)</span> satisfies <span
class="math inline">\(C(d)\)</span> , then any distance <span
class="math inline">\(d{\prime} \leq d\)</span> also satisfies C<span
class="math inline">\((d{\prime})\)</span> ), we can perform a binary
search to find the maximum <span class="math inline">\(d\)</span> that
satisfies <span class="math inline">\(C(d)\)</span> .</li>
<li><strong>Time Complexity</strong>: The time complexity of this
approach is¬† <span class="math inline">\(O(n \log(\text{n}))\)</span>
.</li>
</ol>
<h3 id="code-example-1">2.2.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Validate</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = m;  <span class="comment">// stones to be removed</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">1</span>;  <span class="comment">// position of the first stone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> en = <span class="number">2</span>; en &lt;= n; en++) &#123;  <span class="comment">// position of the last stone</span></span><br><span class="line">        <span class="type">int</span> disCur = dis[en] - dis[st];  <span class="comment">// distance between the current stone and the last one</span></span><br><span class="line">        <span class="keyword">while</span> (disCur &lt; d) &#123;  <span class="comment">// If the distance is less than d, we remove a stone</span></span><br><span class="line">            k--;</span><br><span class="line">            en++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// if we have removed too many stones</span></span><br><span class="line">        <span class="keyword">if</span> (en &gt; n) &#123;  <span class="comment">// special case</span></span><br><span class="line">            <span class="keyword">if</span> (st == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// check distance between the first and last stone</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// can move the first stone and keep the condition</span></span><br><span class="line">        &#125;</span><br><span class="line">        disCur = dis[en] - dis[st];  <span class="comment">// update the distance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        dis.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dis[i]);</span><br><span class="line">            dis[i] += dis[i - <span class="number">1</span>];  <span class="comment">// compute the prefix sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, ub = <span class="number">1000</span> * <span class="number">1000</span> + <span class="number">5</span>;  <span class="comment">// upper bound for the maximum distance</span></span><br><span class="line">        <span class="keyword">while</span> (lb &lt; ub) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Validate</span>(mid)) lb = mid;  <span class="comment">// update the lower bound</span></span><br><span class="line">            <span class="keyword">else</span> ub = mid - <span class="number">1</span>;  <span class="comment">// update the upper bound</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
