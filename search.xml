<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>üëìEnumination</title>
    <url>/2025/02/18/article-1/</url>
    <content><![CDATA[<h1>1. The main idea of enumeration algorithm</h1>
<blockquote>
<p>‚ÄúList all possible solutions to this problem one by one, and in the process of listing, check each possible solution to see if it is the true solution to the problem.‚Äù</p>
</blockquote>
<span id="more"></span> 
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a><br>
<strong>Instruction:</strong></p>
<ol>
<li>
<p><strong>Identify the enumeration objects</strong></p>
</li>
<li>
<p><strong>List possible solutions one by one</strong></p>
</li>
<li>
<p><strong>Verify each possible solution one by one</strong></p>
</li>
</ol>
<h1>2. Typical application examples of enumeration algorithm</h1>
<h2 id="2-1-Array-paring">2.1 Array paring</h2>
<hr>
<h3 id="2-1-1-Problem-Description">2.1.1 <strong>Problem Description</strong></h3>
<p>The problem presented involves selecting two distinct numbers from an array of size n such that their sum is divisible by a given integer $k$. The challenge is to calculate how many different pairs can be chosen, while considering that pairs like $(a_1, a_2)$ and $(a_2, a_1)$ are considered the same.</p>
<p>Given:</p>
<ul>
<li>
<p>An array $A$ of length $n$.</p>
</li>
<li>
<p>A positive integer $k$.</p>
</li>
<li>
<p>The task is to select pairs of numbers $a_i$ and $a_j$ (where $i &lt; j$) such that:</p>
<p>$(a_i + a_j) % k = 0$</p>
</li>
</ul>
<p>Where $a_i$ and $a_j$ are two numbers chosen from the array.</p>
<h3 id="2-1-2-Algorithm-and-Approach">2.1.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li>
<p><strong>Brute Force Enumeration</strong>: The brute force approach would involve looping through all possible pairs of numbers in the array and checking whether their sum is divisible by $k$. This approach has a time complexity of $O(n^2)$, where $n$ is the size of the array. For large values of $n$, this results in $O(10^{12})$ operations, which is computationally expensive.</p>
</li>
<li>
<p><strong>Optimization with Remainder Buckets</strong>: The key observation is to use modulo arithmetic. If we can categorize the numbers by their remainders when divided by k, then we can use this to reduce the complexity.<br>
$B_0$  for numbers where  $a_i % k = 0$ ;  $B_1$  for numbers where  $a_i % k = 1$‚Ä¶</p>
<p><strong>Pair Counting Function:</strong><br>
if  $(i + j) % k = 0$  and $i‚â†j$ :  $\text{count}(B_i) \times \text{count}(B_j)$<br>
if $i=j$ :  $\frac{\text{count}(B_i) \times (\text{count}(B_i) - 1)}{2}$</p>
</li>
<li>
<p><strong>Time Complexity:</strong> The time complexity of this optimized solution is  $O(n + k)$ , as we only need to iterate through the array once to categorize the numbers, and then we iterate through the  $k$  buckets to count pairs.</p>
</li>
</ol>
<h3 id="2-1-3-Code-Example">2.1.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>]; <span class="comment">// Array to count numbers in remainder buckets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// Reset the array</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[t % k]++; <span class="comment">// Count numbers by remainder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (k - i) % k;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="keyword">break</span>; <span class="comment">// Avoid counting the same pairs twice</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == j) ans += <span class="number">1LL</span> * a[i] * (a[i] - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// Special case for same remainder</span></span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">1LL</span> * a[i] * a[j]; <span class="comment">// Count valid pairs from different remainder groups</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Stone-Removal">2.2 <strong>Stone Removal</strong></h2>
<h3 id="2-2-1-Problem-Description">2.2.1 <strong>Problem Description</strong></h3>
<p>In this problem, we are given a river with stones arranged along its length, and the goal is to remove some stones such that the remaining stones have a minimal distance between two consecutive stones. The task is to remove a maximum of  $m$  stones and maximize the minimum distance between the remaining consecutive stones.</p>
<p>Given:</p>
<ul>
<li>A sequence of stones represented as an array  $S = [s_1, s_2, \dots, s_n]$ , where the distance between two consecutive stones is provided.</li>
<li>A positive integer  $m$ , which represents the maximum number of stones that can be removed.</li>
<li>The objective is to determine the maximum minimum distance between consecutive stones after removing up to  $m$  stones.</li>
</ul>
<p>Input:</p>
<p>The input consists of multiple test cases (up to 20).</p>
<p>Each test case consists of two integers:</p>
<ul>
<li>$n$  ($2 ‚â§$  $n$  $‚â§ 1000$), representing the number of stones.</li>
<li>$m$  ($0 ‚â§  m \leq n-2$ ), the maximum number of stones that can be removed.</li>
<li>Then follow  $n-1$  integers representing the distances between adjacent stones.</li>
</ul>
<p>Output:</p>
<p>For each test case, output the maximum possible minimum distance between any two consecutive stones after removing up to  $m$  stones.</p>
<h3 id="2-2-2-Algorithm-and-Approach">2.2.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li><strong>Validate Function</strong>¬† $C(d)$ : The function  $C(d)$  checks if we can maintain a minimum distance of  $d$  after removing up to  m  stones. We start with the first stone and try to place the subsequent stones such that their distance from the last placed stone is at least  $d$ .</li>
<li><strong>Binary Search Optimization</strong>:¬†Since  $C(d)$  is a monotonic function (if a distance  $d$  satisfies  $C(d)$ , then any distance  $d{\prime} \leq d$  also satisfies  C$(d{\prime})$ ), we can perform a binary search to find the maximum  $d$  that satisfies  $C(d)$ .</li>
<li><strong>Time Complexity</strong>: The time complexity of this approach is¬† $O(n \log(\text{n}))$ .</li>
</ol>
<h3 id="2-2-3-Code-Example">2.2.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Validate</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = m;  <span class="comment">// stones to be removed</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">1</span>;  <span class="comment">// position of the first stone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> en = <span class="number">2</span>; en &lt;= n; en++) &#123;  <span class="comment">// position of the last stone</span></span><br><span class="line">        <span class="type">int</span> disCur = dis[en] - dis[st];  <span class="comment">// distance between the current stone and the last one</span></span><br><span class="line">        <span class="keyword">while</span> (disCur &lt; d) &#123;  <span class="comment">// If the distance is less than d, we remove a stone</span></span><br><span class="line">            k--;</span><br><span class="line">            en++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// if we have removed too many stones</span></span><br><span class="line">        <span class="keyword">if</span> (en &gt; n) &#123;  <span class="comment">// special case</span></span><br><span class="line">            <span class="keyword">if</span> (st == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// check distance between the first and last stone</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// can move the first stone and keep the condition</span></span><br><span class="line">        &#125;</span><br><span class="line">        disCur = dis[en] - dis[st];  <span class="comment">// update the distance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        dis.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dis[i]);</span><br><span class="line">            dis[i] += dis[i - <span class="number">1</span>];  <span class="comment">// compute the prefix sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, ub = <span class="number">1000</span> * <span class="number">1000</span> + <span class="number">5</span>;  <span class="comment">// upper bound for the maximum distance</span></span><br><span class="line">        <span class="keyword">while</span> (lb &lt; ub) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Validate</span>(mid)) lb = mid;  <span class="comment">// update the lower bound</span></span><br><span class="line">            <span class="keyword">else</span> ub = mid - <span class="number">1</span>;  <span class="comment">// update the upper bound</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>üï∂Ô∏è Divide and Conquer</title>
    <url>/2025/02/24/Divide-and-Conquer-1/</url>
    <content><![CDATA[<h1 id="the-main-idea-of-divide-and-conquer-algorithm">1. The main idea
of divide and conquer algorithm</h1>
<blockquote>
<p>The divide-and-conquer strategy algorithm consists of three stages:
Divide, Conquer, and Combine. The Divide stage is where the original
problem is divided into smaller subproblems. The Conquer stage involves
recursively solving the subproblems. The Combine stage is where the
solutions to the subproblems are combined to form the solution to the
original problem.</p>
</blockquote>
<span id="more"></span>
<h1 id="divide-and-conquer-algorithm-framework">2. divide and conquer
algorithm framework</h1>
<p>The pseudocode for the divide-and-conquer algorithm is as
follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(P):</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">if</span> (|P| &lt;= n0) <span class="built_in">adhoc</span>(P);  <span class="comment">// Base case, solve the problem directly</span></span><br><span class="line">(<span class="number">2</span>) divide P into smaller subinstances P1, P2, ..., Pk;  <span class="comment">// Divide the problem</span></span><br><span class="line">(<span class="number">3</span>) <span class="keyword">for</span> (i = <span class="number">1</span>, i &lt;= k, i++) &#123;</span><br><span class="line">    yi = divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(Pi);  <span class="comment">// Recursively solve subproblems</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">merge</span>(y1, ..., yk);  <span class="comment">// Combine the solutions of subproblems</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Base Case</strong> (adhoc(P)): When the size of the problem
is small enough (below a threshold¬† <span
class="math inline">\(n_0\)</span> ), we use a direct approach to solve
it, without further division. This is the termination point for
recursion.</li>
<li><strong>Divide Step</strong>: In this step, the original problem¬†
<span class="math inline">\(P\)</span>¬† is divided into smaller
subproblems¬† <span class="math inline">\(P_1, P_2, ‚Ä¶, P_k\)</span> . The
goal is to make these subproblems small enough so they can be handled
easily.</li>
<li><strong>Merge Step</strong>: After solving the subproblems, their
solutions are merged together to form the solution to the original
problem. This merging process is key to the divide-and-conquer
approach.</li>
<li><strong>Designing the Strategy:</strong> The design of a
divide-and-conquer strategy involves dividing the original problem into
k smaller subproblems. This step is crucial and can be approached with
two principles.
<ul>
<li><strong>Balanced Subproblems</strong>: Ideally, the size of the
subproblems should be balanced, meaning that the problems should be
divided such that each subproblem is roughly the same size.</li>
<li><strong>Independent Subproblems</strong>: The subproblems should be
as independent as possible, meaning that the solutions to the
subproblems should not interfere with each other.</li>
</ul></li>
</ul>
<h1 id="typical-application-examples-of-divide-and-conquer-algorithm">3.
Typical application examples of divide and conquer algorithm</h1>
<h2 id="chessboard-covering-problem">3.1 Chessboard Covering
Problem</h2>
<h3 id="problem-statement">3.1.1 <strong>Problem Statement</strong></h3>
<p>Given an integer k ( 1 k ), the chessboard size is 2^k ^k . The
special square is given by coordinates (x, y) , where 0 x, y . he board
must be fully covered using <strong>L-shaped trominoes</strong>, which
come in <strong>four different orientations</strong> (numbered 1, 2, 3,
and 4 as shown in the image). Each L-tromino consists of three
squares.</p>
<figure>
<img src="attachment:b59e2c4b-c274-41ac-8fdd-0ace58db63de:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>Input</strong></p>
<ul>
<li>An integer¬† k¬† representing the chessboard size¬† 2^k ^k .</li>
<li>Two integers¬† x, y¬† representing the position of the special
square.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>A¬† 2^k ^k¬† matrix where:</li>
<li>The special square is marked as 0.</li>
<li>Other cells are filled with numbers 1, 2, 3, or 4, indicating which
L-tromino covers them.</li>
<li>The output values are separated by <strong>tab spaces</strong>.</li>
</ul>
<h3 id="algorithm-and-approach">3.1.2 <strong>Algorithm and
Approach</strong></h3>
<figure>
<img src="attachment:d7796dee-ca1f-4b98-9cf0-09cb25c433d1:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:0a1d8ab8-7782-43f3-bc49-0c81ebdb0a52:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:4fb313a5-1781-4bc0-94c7-cc60d80d1de7:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="code-example">3.1.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="comment">// Coordinates of the special square</span></span><br><span class="line"><span class="type">int</span> dr, dc;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">2</span>, k);</span><br><span class="line"><span class="type">int</span> Board[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc)</span> &#123; <span class="comment">// Merge function</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">2</span>)</span><br><span class="line">		fill(tr, tc, dr, dc); <span class="comment">// Recursion base case</span></span><br><span class="line">	<span class="type">int</span> s = size / <span class="number">2</span>; <span class="comment">// Divide into subproblems</span></span><br><span class="line">	<span class="comment">// Special square is in the top-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">		ChessBoard(tr, tc, dr, dc, s); <span class="comment">// Recursively process top-left quadrant</span></span><br><span class="line">		ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s); <span class="comment">// Recursively process top-right quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s); <span class="comment">// Recursively process bottom-left quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc + s, tr + s, tc + s, s); <span class="comment">// Recursively process bottom-right quadrant</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the top-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="merge-sort">3.2 Merge Sort</h2>
<h3 id="problem-statement-1">3.2.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-1">3.2.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</li>
<li>Merge: A function merge is used to combine two already sorted
subarrays B_1 and B_2 into a single sorted array B .</li>
</ul>
<h3 id="code-example-1">3.2.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = iLow;</span><br><span class="line">	<span class="type">int</span> j = iMid + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k = iLow;</span><br><span class="line">	<span class="keyword">while</span> ((i &lt;= iMid) &amp;&amp; (j &lt;= iHigh)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy the remaining elements</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= iMid) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt; iMid; ii++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[ii];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[jj];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123; <span class="comment">// Base case for recursion</span></span><br><span class="line">		<span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>; <span class="comment">// Divide the array</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iLow, iMid); <span class="comment">// Recursive call for left half</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iMid+<span class="number">1</span>, iHigh); <span class="comment">// Recursive call for right half</span></span><br><span class="line">		merge(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Merge the two halves</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) &#123;</span><br><span class="line">			iDatas[i] = iBuffer[i]; <span class="comment">// Copy sorted elements back to original array</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="quick-sort">3.3 Quick Sort</h2>
<h3 id="problem-statement-2">3.3.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-2">3.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><p>Divide: Split the original array A into two equal parts and one
pivot element</p>
<p><strong>Quick Sort</strong> is a <strong>Divide and Conquer</strong>
algorithm that sorts an array by selecting a <strong>pivot</strong> and
partitioning the array into two subarrays:</p>
<ol type="1">
<li><p><strong>Elements smaller than the pivot</strong> go to the
left.</p></li>
<li><p><strong>Elements greater than the pivot</strong> go to the
right.</p></li>
</ol></li>
<li><p>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</p></li>
</ul>
<aside>
<p>üí°</p>
<p><strong>Quick Sort does not have a merge step</strong>.</p>
<p>Merge Sort keeps dividing into two segments. Quick Sort keeps
dividing into three segments.</p>
</aside>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th><strong>Sorting Algorithm</strong></th>
<th><strong>Uses Merging?</strong></th>
<th><strong>Key Operation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Quick Sort</strong></td>
<td>‚ùå <strong>No</strong></td>
<td><strong>Partitioning</strong> (placing smaller elements on the left,
larger on the right)</td>
</tr>
<tr>
<td><strong>Merge Sort</strong></td>
<td>‚úÖ <strong>Yes</strong></td>
<td><strong>Merging</strong> (combining sorted subarrays back
together)</td>
</tr>
</tbody>
</table>
<h3 id="code-example-2">3.3.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Quick Sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; iValue1, <span class="type">int</span>&amp; iValue2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> iTemp = iValue1;</span><br><span class="line">	iValue1 = iValue2;</span><br><span class="line">	iValue2 = iTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = iLow + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> j = iHigh;</span><br><span class="line">	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &gt;= iDatas[i]) &amp;&amp; (i &lt;= iHigh)) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &lt;= iDatas[j]) &amp;&amp; (j &gt;= iHigh)) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(iDatas[i], iDatas[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(iDatas[iLow], iDatas[j]);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123;</span><br><span class="line">		<span class="type">int</span> k = <span class="built_in">partition</span>(iDatas, iLow, iHigh);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, iLow, k - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, k + <span class="number">1</span>, iHigh);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="time-complexity-analysis">3.3.4 Time Complexity Analysis</h3>
<ol type="1">
<li><strong>Average-Case/Best-Case Scenario</strong>: The best case
occurs when the pivot always divides the array into two equal or nearly
equal halves, such as when the array is already sorted or the pivot
selection ensures balanced partitions (e.g., the median element).<span
class="math inline">\(O(nlogn)\)</span></li>
<li><strong>Worst-Case Scenario</strong>: The worst case occurs when the
pivot consistently produces highly unbalanced partitions, such as when
the array is already sorted (in ascending or descending order) and the
pivot is the smallest or largest element.<span
class="math inline">\(O(n^2)\)</span></li>
</ol>
<h3 id="quick-sort-improvement">3.3.5 Quick Sort improvement</h3>
<p><strong>QuickSort‚Äôs performance depends on the choice of
pivot.</strong> Randomized QuickSort mitigates this by randomly
selecting the pivot, ensuring a more balanced partition on average and
reducing the likelihood of worst-case scenarios.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">randomizedQuickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLeft, <span class="type">int</span> iRight)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iRight &gt; iLeft) &#123;</span><br><span class="line">        srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> iAncharIndex = rand() % (iRight - iLeft + <span class="number">1</span>) + iLeft;</span><br><span class="line">        swap(iDatas[iAncharIndex], iDatas[iLeft]);</span><br><span class="line">        <span class="type">int</span> k = partition(iDatas, iLeft, iRight);</span><br><span class="line">        randomizedQuickSort(iDatas, iLeft, k<span class="number">-1</span>); <span class="comment">// Sort the left subarray A1</span></span><br><span class="line">        randomizedQuickSort(iDatas, k+<span class="number">1</span>, iRight); <span class="comment">// Sort the right subarray A3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inversion-pair-problem">3.4 Inversion Pair Problem</h2>
<h3 id="problem-statement-3">3.4.1 <strong>Problem
Statement</strong></h3>
<p>Given an array <strong>A</strong> of <strong>n</strong> distinct
non-negative integers, an <strong>inversion pair</strong> (A[i], A[j])
is defined as a pair where¬† i &lt; j¬† and¬† A[i] &gt; A[j] . The task is
to count the number of such inversion pairs in the array.</p>
<p><strong>Input</strong></p>
<p>Each test case consists of two lines:</p>
<ol type="1">
<li><p>The first line contains an integer¬† n¬† ( 1 n ), representing the
number of elements in the array.</p></li>
<li><p>The second line contains <strong>n</strong> space-separated
integers.</p></li>
<li><p>The last input line is <strong>-1</strong>, indicating the end of
input.</p></li>
</ol>
<p><strong>Output</strong></p>
<p>For each test case, output a single integer in a new line,
representing the total number of inversion pairs in the array.</p>
<h3 id="algorithm-and-approach-3">3.4.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it don‚Äôt include
the inversion pairs; Otherwise, recursively divide the subarrays
further</li>
<li>Merge: The approach is divided into three main components (C1, C2,
and C3), and the total inversion count C is the sum of these components:
<span class="math inline">\(*C=C_1+C_2+C_3*\)</span>
<ul>
<li>C1: Inversions within the left segment of the array</li>
<li>C2: Inversions within the right segment of the array</li>
<li>C3: Inversions across the two segments</li>
</ul></li>
</ul>
<aside>
<p>üí°</p>
<p>How to compute C3? The key insight is to use the merge process of
merge sort.</p>
</aside>
<figure>
<img src="attachment:1a8628fe-59b6-48c3-aaab-6bfcdd8f1d29:image.png"
alt="easy to understand explanation" />
<figcaption aria-hidden="true">easy to understand
explanation</figcaption>
</figure>
<p>easy to understand explanation</p>
<h3 id="code-example-3">3.4.3 <strong>Code Example</strong></h3>
<p>main:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">reverseOrderPairs</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iLow == iHigh) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Base case: single element</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> C1, C2, C3;</span><br><span class="line"></span><br><span class="line">    C1 = reverseOrderPairs(iDatas, iBuffer, iLow, iMid); <span class="comment">// Count inversions in the left segment</span></span><br><span class="line">    C2 = reverseOrderPairs(iDatas, iBuffer, iMid + <span class="number">1</span>, iHigh); <span class="comment">// Count inversions in the right segment</span></span><br><span class="line">    C3 = MergeReverse(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Count inversions across segments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) <span class="comment">// Copy back the sorted result to the original array</span></span><br><span class="line">        iDatas[i] = iBuffer[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C1 + C2 + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge step:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Merge the segments iData[iLow:iMid] and iData[iMid+1:iHigh] into iBuffer[iLow:iHigh],</span></span><br><span class="line"><span class="comment">// and count the number of inversions within the merged segments</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">MergeReverse</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = iLow, j = iMid + <span class="number">1</span>, k = iLow;</span><br><span class="line">    <span class="type">long</span> iCrossPairs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iMid &amp;&amp; j &lt;= iHigh) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">            iBuffer[k++] = iDatas[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Count inversion pairs: if iDatas[i] &gt; iDatas[j], all remaining elements in the left segment</span></span><br><span class="line">            <span class="comment">// from i to iMid form inversion pairs with iDatas[j]</span></span><br><span class="line">            iCrossPairs += iMid - i + <span class="number">1</span>;</span><br><span class="line">            iBuffer[k++] = iDatas[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= iMid) <span class="comment">// Copy remaining elements in the left segment [iLow:iMid]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt;= iMid; ii++)</span><br><span class="line">            iBuffer[k++] = iDatas[ii];</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Copy remaining elements in the right segment [iMid+1:iHigh]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++)</span><br><span class="line">            iBuffer[k++] = iDatas[jj];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iCrossPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binary-search">3.5 Binary Search</h2>
<p>Any given set containing n integers, and n integers have been
arranged in ascending order. Given any integer k, judge whether the
integer is in the set. classic divide and conquer problem(‚ùåmerge
step)</p>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ü•Ω Divide and Conquer(The closest pairs of points)</title>
    <url>/2025/02/24/Divide-and-Conquer-The-closest-pairs-of-points/</url>
    <content><![CDATA[<h1 id="problem-statement">1. <strong>Problem Statement</strong></h1>
<p>Given a set of ( n ) points on a 2D plane, find a pair of points such
that the distance between them is the minimum among all possible pairs
of points in the set.</p>
<span id="more"></span>
<p><strong>Input:</strong></p>
<ul>
<li>Each test case begins with a single integer ( n ), representing the
number of points on the plane.</li>
<li>This is followed by ( n ) lines (where ( n &lt; 100,000 )), each
containing two integers representing the x-coordinate and y-coordinate
of a point.</li>
<li>The input ends with a line containing -1, indicating the end of all
test cases.</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>For each test case, output a single line containing the distance
between the closest pair of points, rounded to an appropriate precision
(typically an integer or with a specific number of decimal places,
depending on the problem‚Äôs requirements).</li>
</ul>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">0 8</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="algorithm-and-approach">2. <strong>Algorithm and
Approach</strong></h1>
<ul>
<li><p>Divide: Choose a vertical line <span class="math inline">\(l: x =
m\)</span> as the dividing line, where m is the median of the
x-coordinates of the points in <span class="math inline">\(S\)</span> .
Split <span class="math inline">\(S\)</span> into <span
class="math inline">\(S_1\)</span> and <span
class="math inline">\(S_2\)</span> .</p></li>
<li><p>Conquer: Recursively find the minimum distances d_1 and d_2 in
S_1 and S_2 , respectively, and set d = {d_1, d_2} .</p>
<aside>
<p>üí°</p>
<p>Compress the enumeration space</p>
</aside></li>
</ul>
<figure>
<img src="attachment:7b36543f-3a54-43fe-815f-b8fec41f7897:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Merge: The closest pair of points in S is either d or a pair {p, q}
where p S_1 and q S_2 .
<ul>
<li><p>Candidate points p and q must be within a distance of at most d
from the line l , so only the ranges P_1 and P_2 need to be
considered.</p></li>
<li><p>For any point p in P_1 , if it forms a candidate for the closest
pair with a point q in P_2 , then it must satisfy: (p, q) &lt; d. The
points in P_2 that meet this condition must lie within a d 2d rectangle
R .</p></li>
<li><p>From the definition of d , we know that any two points in S
within P_2 are at least d apart. Therefore, it follows that there can be
at most 6 points from S within the rectangle R . <strong>Proof:</strong>
In the 2D space ( R^2 ), there are ( 2d ) points divided into two sets
of ( d ) points each, labeled as the left set and the right set. We can
assume there is at least one point pair ((d/2) (2d/3)) that forms the
closest pair. The space ( R^2 ) has 6 strips of ( S ), and by combining
the results of these strips, we can identify a unique point pair ((d/2)
(2d/3)) where there are 2 points within ( S ) that are the closest. Let
( u ) and ( v ) be two points in one of the 6 strips of ( S ), and:</p>
<p>The distance between the two points satisfies: [ (x(u) - x(v))^2 +
(y(u) - y(v))^2 (d/2)^2 + (2d/3)^2 = d^2 ] Thus, the distance (
distance(u, v) &lt; d ). This completes the proof of the geometric
reasoning.</p></li>
</ul></li>
</ul>
<h1 id="code-example">3. <strong>Code Example</strong></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ÊúÄËøëÁÇπÂØπ</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">PII p[N];</span><br><span class="line">PII temp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//ËÆ°ÁÆó‰∏§ÁÇπ‰πãÈó¥ÁöÑÊ¨ßÂá†ÈáåÂæóË∑ùÁ¶ª</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">dist</span><span class="params">(PII a, PII b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dis</span><span class="params">(<span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iLow&gt;=iHigh)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(iLow+<span class="number">1</span>==iHigh)&#123;</span><br><span class="line">        <span class="keyword">return</span> dist(p[iLow], p[iHigh]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> iMid=(iLow+iHigh)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> l_dis=dis(iLow,iMid);</span><br><span class="line">        <span class="type">double</span> r_dis=dis(iMid+<span class="number">1</span>,iHigh);</span><br><span class="line">        <span class="type">double</span> d=min(l_dis,r_dis);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=iLow;i&lt;=iHigh;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(p[i].x-p[iMid].x)&lt;d)&#123;</span><br><span class="line">                temp[t]=p[i];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(temp,temp+t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;t;j++)&#123;</span><br><span class="line">                d=min(d,dist(temp[i],temp[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, dis(<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reduction-strategy">4. Reduction strategy</h1>
<blockquote>
<p>In a divide-and-conquer algorithm, if a certain (or some) subproblem
is irrelevant to the solution of the original problem or identical to
another subproblem, then this (or these) subproblem(s) do not need to be
solved recursively and can be directly discarded or replaced with an
existing result.</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ü•ºDynamic Programming</title>
    <url>/2025/02/26/Dynamic-Programming/</url>
    <content><![CDATA[<h1 id="the-main-idea-of-dynamic-programming-algorithm">1. The main idea
of Dynamic Programming algorithm</h1>
<h2 id="prologuenumber-triangle-path-problem">1.1
Prologue‚Äî‚Äî<strong>Number Triangle Path Problem</strong></h2>
<p>Given an isosceles right-angled number triangle, write a program to
compute a path from the top to a specific position at the bottom such
that the sum of the numbers along the path is maximized. It is assumed
that at each step, one can move either straight down or diagonally down
to the right. <span id="more"></span></p>
<ul>
<li>a[i][j] represents the number at row i and column j</li>
<li>opt[i][j] records the maximum total sum of a path from the top to
the position at row i , column j</li>
</ul>
<ol type="1">
<li><span class="math inline">\(j=1\)</span> <span
class="math inline">\(opt[i][j] = a[i][j] + opt[i-1][j]\)</span></li>
<li><span class="math inline">\(j &gt; 1\)</span> <span
class="math inline">\(opt[i][j] = a[i][j] + max(opt[i-1][j],
opt[i-1][j-1])\)</span></li>
</ol>
<p>result: max{<span class="math inline">\(opt[N][i], 1 &lt;= i &lt;=
N\)</span>}</p>
<h2 id="background">1.2 Background</h2>
<p>Dynamic programming is a branch of operations research. In the early
1950s, the American mathematician R.E. Bellman and others proposed the
famous <strong>principle of optimality</strong> while studying
optimization problems in <strong>multistep decision processes</strong>.
This principle transforms a multistage process into a series of
single-stage problems and solves them sequentially by leveraging the
relationships between stages. This led to the development of a new
method for solving such optimization problems‚Äî<strong>dynamic
programming</strong>.</p>
<h2 id="important-definition">1.3 Important Definition</h2>
<ul>
<li><strong>State Representation:</strong> Represents the
<strong>objective situation</strong> of the problem or system at the
beginning of each stage. A stage may have multiple states, each
represented as a tuple <strong>S(p‚ÇÅ, p‚ÇÇ, ‚Ä¶, p‚Çñ)</strong>:
<strong>Parameters</strong> describe state attributes. <strong>Value
domain</strong> represents state values or subproblem
<strong>answers</strong>. Like: <span class="math inline">\(opt(i,
j)\)</span></li>
<li><strong>State Transition:</strong> In a <strong>multistage decision
process</strong>, a decision sequence corresponds to a sequence of
states, with each decision leading to a <strong>state
transition</strong>. State transitions are described using a
<strong>recursive equation</strong>, referred to as the <strong>state
transition equation</strong>. Like: <span class="math inline">\(opt(i,
j) = a[i][j] + max(opt(i-1,j), opt(i-1,j-1))\)</span>
<ul>
<li><strong>State Independence (No Aftereffect Property):</strong> Once
the state of a certain stage is determined, the future development of
this stage is <strong>independent</strong> of the states of all previous
stages.</li>
<li><strong>Principle of Optimality:</strong> A sub-strategy sequence of
an <strong>optimal strategy sequence</strong> must always be
<strong>optimal</strong> itself.</li>
</ul></li>
</ul>
<h1
id="typical-application-examples-of-dynamic-programming-algorithm">2.
Typical application examples of Dynamic Programming algorithm</h1>
<h2 id="matrix-multiplication-problem">2.1 Matrix multiplication
problem</h2>
<h3 id="problem-statement">2.1.1 <strong>Problem Statement</strong></h3>
<p><strong>Problem Description:</strong></p>
<p>Consider the multiplication of two matrices: <strong>C = A √ó
B</strong>. If matrix <strong>A</strong> has dimensions <strong>p √ó
r</strong> and matrix <strong>B</strong> has dimensions <strong>r √ó
q</strong>, then their product <strong>C</strong> will be a <strong>p √ó
q</strong> matrix, where each element <strong>(i, j)</strong> is given
by. Thus, the number of scalar multiplications required for computing
<strong>AB</strong> is <strong>p √ó r √ó q</strong>.</p>
<p>If there are at least <strong>three</strong> matrices being
multiplied together, the <strong>order of multiplication</strong>
affects the total number of computations. For example, for three
matrices, there are two possible ways to insert parentheses:</p>
<ol type="1">
<li><p><strong>((A‚ÇÅ √ó A‚ÇÇ) √ó A‚ÇÉ)</strong></p></li>
<li><p><strong>(A‚ÇÅ √ó (A‚ÇÇ √ó A‚ÇÉ))</strong></p></li>
</ol>
<p>Let <strong>A‚ÇÅ, A‚ÇÇ, A‚ÇÉ</strong> have dimensions <strong>p‚ÇÄ √ó p‚ÇÅ, p‚ÇÅ √ó
p‚ÇÇ, p‚ÇÇ √ó p‚ÇÉ</strong>, respectively. The number of scalar multiplications
for each order is: <strong>((A‚ÇÅ √ó A‚ÇÇ) √ó A‚ÇÉ); (A‚ÇÅ √ó (A‚ÇÇ √ó
A‚ÇÉ))</strong>.</p>
<p>The goal is to find the <strong>optimal parenthesization</strong> for
<strong>n</strong> given matrices <strong>A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çô</strong>, with
dimensions <strong>p‚ÇÄ √ó p‚ÇÅ, p‚ÇÅ √ó p‚ÇÇ, ‚Ä¶, p‚Çô‚Çã‚ÇÅ √ó p‚Çô</strong>, such that
the <strong>total number of scalar multiplications is
minimized</strong>.</p>
<h3 id="algorithm-and-approach">2.1.2 <strong>Algorithm and
Approach</strong></h3>
<aside>
<p>üí°</p>
<p>State representation is essentially a parameterized description of
subproblems.</p>
</aside>
<ul>
<li><p><strong>State Transition:</strong></p>
<p><span class="math inline">\(A[i][j]\)</span>the number of
multiplications corresponding to the optimal computation order: <span
class="math inline">\(m(i,j)\)</span></p></li>
</ul>
<aside>
<p>üí°</p>
<p>It establishes the relationship between the optimal solution of the
original problem and the optimal solutions of its subproblems.</p>
</aside>
<ul>
<li><p><strong>State Transition:</strong></p>
<p>Given n rectangles <span class="math inline">\(A‚ÇÅ, ‚Ä¶, A‚Çô\)</span>,
where each rectangle‚Äôs side length is <span
class="math inline">\(p_{i-1} √ó p_i\)</span>, and one of their complete
doubling square schemes:</p>
<p>((A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çñ)) ((A‚Çñ‚Çä‚ÇÅ, A‚Çñ‚Çä‚ÇÇ, ‚Ä¶, A‚Çô)) : <span
class="math inline">\(a\)</span></p>
<p>(A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çñ): <span class="math inline">\(b\)</span></p>
<p>((A‚Çñ‚Çä‚ÇÅ, A‚Çñ‚Çä‚ÇÇ, ‚Ä¶, A‚Çô)): <span class="math inline">\(c\)</span></p>
<p><span class="math inline">\(a = b + c + P_0P_kP_n\)</span></p>
<p><strong>a</strong> ‚Äî is not the optimal value!!</p>
<p>If <strong>a</strong> is the optimal value, what about
<strong>b</strong> and <strong>c</strong>?</p>
<p><strong>provement:</strong></p>
<p>Construct another doubling square scheme for the original
problem,</p>
<p><span class="math inline">\(a&#39; = b&#39; + c + P_0P_kP_n\)</span>
<span class="math inline">\(a = b + c + P_0P_kP_n\)</span> <span
class="math inline">\(b&#39; &lt; b\)</span></p>
<p>so, <span class="math inline">\(a&#39; &lt; a\)</span></p></li>
</ul>
<p><span
class="math inline">\(m(i,j)=m(i,k)+m(k+1,j)+P_{i-1}P_kP_{j}\)</span>,
so <span class="math inline">\(m(i, j) =
\begin{cases}
0 &amp; \text{if } i = j \\
\min_{i \leq k &lt; j} \{ m(i, k) + m(k + 1, j) + p_{i-1} p_k p_j \}
&amp; \text{if } i &lt; j
\end{cases}\)</span></p>
<p><strong>Example:</strong></p>
<table>
<thead>
<tr>
<th>A1=(a0a1)</th>
<th>A2=(a1a2)</th>
<th>A3=(a2a3)</th>
<th>A4</th>
<th>A5</th>
<th>A6</th>
</tr>
</thead>
<tbody>
<tr>
<td>30√ó35</td>
<td>35√ó15</td>
<td>15√ó5</td>
<td>5√ó10</td>
<td>10√ó20</td>
<td>20√ó25</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>15750=(a0a1a2)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=1</td>
<td>7875</td>
<td>9375</td>
<td>11875</td>
<td>15125</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td><strong>2625</strong>=(a1a2a3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=2</td>
<td>4375</td>
<td>7125</td>
<td>10500</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>750</td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=3</td>
<td>2500</td>
<td>5375</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>**1000</td>
<td></td>
</tr>
<tr>
<td>s=4**</td>
<td>3500</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>5000</td>
</tr>
<tr>
<td>s=5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="memoization-method">2.1.3 memoization method</h3>
<blockquote>
<p>The memoization method stores the solutions to solved subproblems in
a table. When the same problem needs to be solved again, the answer can
be retrieved directly from the table without recalculating. If the
solution has not been computed, the recursive solving process is called
to calculate it.</p>
</blockquote>
<h2 id="shortest-path-in-a-multistage-graph">2.2 Shortest Path in a
Multistage Graph</h2>
<h3 id="problem-statement-1">2.2.1 <strong>Problem
Statement</strong></h3>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a weighted
directed graph, where the vertex set <span
class="math inline">\(V\)</span> is partitioned into <span
class="math inline">\(k\)</span> (with <span class="math inline">\(k
&gt; 2\)</span> ) disjoint subsets <span
class="math inline">\(V_i\)</span> (for <span class="math inline">\(1
\leq i \leq k\)</span> ). The subsets <span
class="math inline">\(V_1\)</span> and <span
class="math inline">\(V_k\)</span> each contain only one vertex, s
(called the source) and t (called the sink), respectively. All edges
(<span class="math inline">\(u, v)\)</span> in the graph have their
start and end vertices in adjacent subsets <span
class="math inline">\(V_i\)</span> and <span
class="math inline">\(V_{i+1}\)</span> , where <span
class="math inline">\(u \in V_i\)</span> , <span class="math inline">\(v
\in V_{i+1}\)</span> , and each edge <span class="math inline">\((u,
v)\)</span> has a positive weight <span class="math inline">\(w(u,
v)\)</span> .</p>
<figure>
<img src="attachment:04240348-eb66-4a0e-9390-1fae26814f6d:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Design an algorithm to find the minimum weight path from the source
<span class="math inline">\(s\)</span> to the sink <span
class="math inline">\(t\)</span> .</p>
<h3 id="algorithm-and-approach-1">2.2.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><p><strong>State Representation:</strong> <span
class="math inline">\(\text{d}(s, v(i, p))\)</span> represents the
shortest path length from the source s to the vertex <span
class="math inline">\(v(i, p)\)</span> . <span
class="math inline">\(i\)</span> represents the segment index. <span
class="math inline">\(p\)</span> represents the vertex index within the
<span class="math inline">\(i\)</span> -th segment.</p></li>
<li><p><strong>State Transition:</strong> need the provement</p>
<p><span class="math inline">\(W(i, p) =
  \begin{cases}
  0, &amp; i = 1 \\
  \min_{q \in V_{i-1}, (q, p) \in E} \{ W(i-1, q) + w(q, p) \}, &amp; i
&gt; 1
  \end{cases}\)</span></p></li>
</ul>
<figure>
<img src="attachment:26289fe2-4213-4336-804c-a1642b7fb994:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><span class="math inline">\(W[i,p]\)</span> cannot be accessed. Use
the predecessor s<em>s</em> to retrieve the shortest path record <span
class="math inline">\(v(i,p)\)</span></p>
<h2 id="longest-common-subsequence">2.3 Longest Common Subsequence</h2>
<h3 id="problem-statement-2">2.3.1 <strong>Problem
Statement</strong></h3>
<p>Assume there is another set of keys <span class="math inline">\(X =
\{x_1, x_2, \dots, x_m\}\)</span> and <span class="math inline">\(Y =
\{y_1, y_2, \dots, y_n\}\)</span> , which leads to the optimal binary
search tree for this set of keys. suppose <span class="math inline">\(Z
= \{B, C, D, B\}\)</span> is the set of keys <span
class="math inline">\(X = \{A, B, C, B, D, A, B\}\)</span> , and the
probability of the keys under the tree is {2, 3, 5, 7} .</p>
<h3 id="algorithm-and-approach-2">2.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><strong>State Representation: <span class="math inline">\(C(m,
n)\)</span></strong> represents the length of the longest common
subsequence (LCS) of the two original sequences. Val(i, p), 1 ‚â§ i ‚â§ n, 0
‚â§ p ‚â§ C</li>
<li><strong>State Transition:</strong> <span
class="math inline">\(c[i][j] =
\begin{cases}
0 &amp; i = 0, j = 0 \\
c[i - 1][j - 1] + 1 &amp; i, j &gt; 0; x_i = y_j \\
\max\{c[i][j - 1], c[i - 1][j]\} &amp; i, j &gt; 0; x_i \neq y_j
\end{cases}\)</span></li>
</ul>
<h3 id="code-example">2.3.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> strX[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> strY[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DP_memo</span><span class="params">(<span class="type">int</span>* strX, <span class="type">int</span>* strY)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (strX[i - <span class="number">1</span>] == strY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				DP[i][j] = DP[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (DP[i - <span class="number">1</span>][j] &gt; DP[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">				DP[i][j] = DP[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DP[n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; strX[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; strY[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; DP_memo(strX, strY) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="knapsack-problem">2.4 0-1 Knapsack Problem</h2>
<h3 id="problem-statement-3">2.3.1 <strong>Problem
Statement</strong></h3>
<p>Given n items and a knapsack, where the weight of item <span
class="math inline">\(i\)</span> is W<span
class="math inline">\(_i\)</span> and its value is <span
class="math inline">\(V_i\)</span> , and the capacity of the knapsack is
<span class="math inline">\(C\)</span> , the problem is to determine
which items to include in the knapsack in order to maximize the total
value of the items placed in the knapsack.</p>
<h3 id="algorithm-and-approach-3">2.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><strong>State Representation:</strong> The subproblem can be
determined by two parameters: the set of items to be considered for
packing and the available capacity of the knapsack. <span
class="math inline">\(Val(i, p), 1 ‚â§ i ‚â§ n, 0 ‚â§ p ‚â§ C\)</span> This
represents the maximum value that can be achieved with the capacity of
item i and the remaining capacity p. The capacity constraint is {1, 2,
‚Ä¶, i}, which corresponds to the largest possible subset of items.</li>
<li><strong>State Transition: i = 1:</strong> <span
class="math inline">\(Val(1, p) =
\begin{cases}
0, &amp; 0 \leq p &lt; w_1 \\
v_1, &amp; p \geq w_1
\end{cases}\)</span> <strong>i &gt; 1:</strong> <span
class="math inline">\(Val(i, p) =
\begin{cases}
Val(i-1, p), &amp; 0 \leq p &lt; w_i \\
\max(Val(i-1, p), Val(i-1, p - w_i) + v_i), &amp; p \geq w_i
\end{cases}\)</span> where <span class="math inline">\(w_i\)</span> is
the weight of item <span class="math inline">\(i\)</span>, and <span
class="math inline">\(v_i\)</span> is the value of item <span
class="math inline">\(i\)</span>.</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Layer Protocols and Web Security_1</title>
    <url>/2025/03/13/Network-Layer-Protocols-and-Web-Security-1/</url>
    <content><![CDATA[<blockquote>
<p>for my X interview, basically focus on the Computer networks. I really recommend the Neso Academy lesson. And this note also included some seed labs content.</p>
</blockquote>
<h1 id="1-ARP‚Äî‚ÄîAddress-Resolution-Protocol"><a href="#1-ARP‚Äî‚ÄîAddress-Resolution-Protocol" class="headerlink" title="1. ARP‚Äî‚ÄîAddress Resolution Protocol"></a>1. ARP‚Äî‚ÄîAddress Resolution Protocol</h1><aside>
üí°

IP Address‚ÜíMAC Address (Resolving IPv4 addresses to Mac addresses and maintaining a table of mappings)

</aside>

<p>Reverse ARP(RARP)</p>
<h2 id="1-1-ARP-Cache-Poisoning-Attack-Lab"><a href="#1-1-ARP-Cache-Poisoning-Attack-Lab" class="headerlink" title="1.1 ARP Cache Poisoning Attack Lab"></a>1.1 ARP Cache Poisoning Attack Lab</h2><p>ARP protocol is a very simple protocol, and it does not implement any security measure. Under such attack, attackers can fool the victim into accepting forged IP to Mac mapping (redirect).</p>
<p><a href="https://seedsecuritylabs.org/Labs_20.04/Files/ARP_Attack/ARP_Attack.pdf">seedsecuritylabs.org</a></p>
<h3 id="1-1-1-How-to-implement-ARP-Cache-Poisoning"><a href="#1-1-1-How-to-implement-ARP-Cache-Poisoning" class="headerlink" title="1.1.1 How to implement ARP Cache Poisoning?"></a>1.1.1 How to implement ARP Cache Poisoning?</h3><ul>
<li>By using ARP request</li>
<li>By using ARP reply, the ARP Cache table need certain IP address. As the result, it‚Äôs a reply not a request</li>
<li>By using ARP gratuitous message. An <strong>ARP Gratuitous packet</strong> is a special type of <strong>ARP request packet</strong>. When a host needs to update outdated information in the ARP caches of all other hosts, it uses this packet. It does not expect the reply.<ul>
<li>the <code>src_ip == dst_ip</code> is the certain host ip</li>
<li>In the ARP head and Ether head, the <code>dst_mac==ff:ff:ff:ff:ff:ff</code></li>
</ul>
</li>
</ul>
<h3 id="1-1-2-Man-in-the-Middle-Attack-on-Telnet-using-ARP-Cache-Poisoning"><a href="#1-1-2-Man-in-the-Middle-Attack-on-Telnet-using-ARP-Cache-Poisoning" class="headerlink" title="1.1.2 Man in the Middle Attack on Telnet using ARP Cache Poisoning"></a>1.1.2 Man in the Middle Attack on <code>Telnet</code> using ARP Cache Poisoning</h3><p><img src="attachment:c104508d-63ce-4977-8be1-745241b009ca:image.png" alt="image.png"></p>
<ol>
<li><strong>Launch the ARP cache poisoning attack.</strong> In A‚Äôs ARP cache, B‚Äôs IP address is mapped to M‚Äôs MAC address, and in B‚Äôs ARP cache, A‚Äôs IP address is also mapped to M‚Äôs MAC address.</li>
<li><strong>Testing:</strong> using Ping, make sure you close ip forward function. Because if IP forwarding is enabled on M, it will act like legitimate router. <strong>Disable IP forwarding</strong> ‚Üí Ensures that A and B <strong>cannot communicate</strong>, proving ARP poisoning was successful.</li>
<li><strong>Launch the MITM attack:</strong> This time make sure you open the ip forward forwarding. <strong>Enable IP forwarding</strong> ‚Üí Creates a <strong>Man-in-the-Middle (MITM) attack</strong>, where M forwards packets while spying on or modifying the traffic. Such as: change packet payload. </li>
</ol>
<p>Telnet: <strong>Telnet</strong> (short for <strong>Telecommunication Network</strong>) is a <strong>network protocol and command-line tool.</strong> Telnet allows a user to log into a remote system, enabling them to execute commands on that system. It relies on the TCP protocol. </p>
<h3 id="1-1-3-Man-in-the-Middle-Attack-on-Netcat-using-ARP-Cache-Poisoning"><a href="#1-1-3-Man-in-the-Middle-Attack-on-Netcat-using-ARP-Cache-Poisoning" class="headerlink" title="1.1.3 Man in the Middle Attack on Netcat using ARP Cache Poisoning"></a>1.1.3 Man in the Middle Attack on <code>Netcat</code> using ARP Cache Poisoning</h3><p>the host A and B use Netcat to communicate instead of Telnet. </p>
<ul>
<li><strong>Telnet is mainly for remote login</strong> (like SSH but without encryption).</li>
<li><strong>Netcat is a general-purpose networking tool</strong> that supports TCP/UDP, port scanning, file transfer, and even creating a backdoor.</li>
<li><strong>Netcat is more powerful</strong> and is often used for <strong>network troubleshooting, hacking (pentesting), and automation</strong>.</li>
</ul>
]]></content>
      <tags>
        <tag>Web Security</tag>
      </tags>
  </entry>
</search>
