<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>üëìEnumination</title>
    <url>/2025/02/18/article-1/</url>
    <content><![CDATA[<h1>1. The main idea of enumeration algorithm</h1>
<blockquote>
<p>‚ÄúList all possible solutions to this problem one by one, and in the process of listing, check each possible solution to see if it is the true solution to the problem.‚Äù</p>
</blockquote>
<span id="more"></span> 
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a><br>
<strong>Instruction:</strong></p>
<ol>
<li>
<p><strong>Identify the enumeration objects</strong></p>
</li>
<li>
<p><strong>List possible solutions one by one</strong></p>
</li>
<li>
<p><strong>Verify each possible solution one by one</strong></p>
</li>
</ol>
<h1>2. Typical application examples of enumeration algorithm</h1>
<h2 id="2-1-Array-paring">2.1 Array paring</h2>
<hr>
<h3 id="2-1-1-Problem-Description">2.1.1 <strong>Problem Description</strong></h3>
<p>The problem presented involves selecting two distinct numbers from an array of size n such that their sum is divisible by a given integer $k$. The challenge is to calculate how many different pairs can be chosen, while considering that pairs like $(a_1, a_2)$ and $(a_2, a_1)$ are considered the same.</p>
<p>Given:</p>
<ul>
<li>
<p>An array $A$ of length $n$.</p>
</li>
<li>
<p>A positive integer $k$.</p>
</li>
<li>
<p>The task is to select pairs of numbers $a_i$ and $a_j$ (where $i &lt; j$) such that:</p>
<p>$(a_i + a_j) % k = 0$</p>
</li>
</ul>
<p>Where $a_i$ and $a_j$ are two numbers chosen from the array.</p>
<h3 id="2-1-2-Algorithm-and-Approach">2.1.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li>
<p><strong>Brute Force Enumeration</strong>: The brute force approach would involve looping through all possible pairs of numbers in the array and checking whether their sum is divisible by $k$. This approach has a time complexity of $O(n^2)$, where $n$ is the size of the array. For large values of $n$, this results in $O(10^{12})$ operations, which is computationally expensive.</p>
</li>
<li>
<p><strong>Optimization with Remainder Buckets</strong>: The key observation is to use modulo arithmetic. If we can categorize the numbers by their remainders when divided by k, then we can use this to reduce the complexity.<br>
$B_0$  for numbers where  $a_i % k = 0$ ;  $B_1$  for numbers where  $a_i % k = 1$‚Ä¶</p>
<p><strong>Pair Counting Function:</strong><br>
if  $(i + j) % k = 0$  and $i‚â†j$ :  $\text{count}(B_i) \times \text{count}(B_j)$<br>
if $i=j$ :  $\frac{\text{count}(B_i) \times (\text{count}(B_i) - 1)}{2}$</p>
</li>
<li>
<p><strong>Time Complexity:</strong> The time complexity of this optimized solution is  $O(n + k)$ , as we only need to iterate through the array once to categorize the numbers, and then we iterate through the  $k$  buckets to count pairs.</p>
</li>
</ol>
<h3 id="2-1-3-Code-Example">2.1.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>]; <span class="comment">// Array to count numbers in remainder buckets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// Reset the array</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        a[t % k]++; <span class="comment">// Count numbers by remainder</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = (k - i) % k;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="keyword">break</span>; <span class="comment">// Avoid counting the same pairs twice</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == j) ans += <span class="number">1LL</span> * a[i] * (a[i] - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// Special case for same remainder</span></span><br><span class="line">        <span class="keyword">else</span> ans += <span class="number">1LL</span> * a[i] * a[j]; <span class="comment">// Count valid pairs from different remainder groups</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Stone-Removal">2.2 <strong>Stone Removal</strong></h2>
<h3 id="2-2-1-Problem-Description">2.2.1 <strong>Problem Description</strong></h3>
<p>In this problem, we are given a river with stones arranged along its length, and the goal is to remove some stones such that the remaining stones have a minimal distance between two consecutive stones. The task is to remove a maximum of  $m$  stones and maximize the minimum distance between the remaining consecutive stones.</p>
<p>Given:</p>
<ul>
<li>A sequence of stones represented as an array  $S = [s_1, s_2, \dots, s_n]$ , where the distance between two consecutive stones is provided.</li>
<li>A positive integer  $m$ , which represents the maximum number of stones that can be removed.</li>
<li>The objective is to determine the maximum minimum distance between consecutive stones after removing up to  $m$  stones.</li>
</ul>
<p>Input:</p>
<p>The input consists of multiple test cases (up to 20).</p>
<p>Each test case consists of two integers:</p>
<ul>
<li>$n$  ($2 ‚â§$  $n$  $‚â§ 1000$), representing the number of stones.</li>
<li>$m$  ($0 ‚â§  m \leq n-2$ ), the maximum number of stones that can be removed.</li>
<li>Then follow  $n-1$  integers representing the distances between adjacent stones.</li>
</ul>
<p>Output:</p>
<p>For each test case, output the maximum possible minimum distance between any two consecutive stones after removing up to  $m$  stones.</p>
<h3 id="2-2-2-Algorithm-and-Approach">2.2.2 <strong>Algorithm and Approach</strong></h3>
<ol>
<li><strong>Validate Function</strong>¬† $C(d)$ : The function  $C(d)$  checks if we can maintain a minimum distance of  $d$  after removing up to  m  stones. We start with the first stone and try to place the subsequent stones such that their distance from the last placed stone is at least  $d$ .</li>
<li><strong>Binary Search Optimization</strong>:¬†Since  $C(d)$  is a monotonic function (if a distance  $d$  satisfies  $C(d)$ , then any distance  $d{\prime} \leq d$  also satisfies  C$(d{\prime})$ ), we can perform a binary search to find the maximum  $d$  that satisfies  $C(d)$ .</li>
<li><strong>Time Complexity</strong>: The time complexity of this approach is¬† $O(n \log(\text{n}))$ .</li>
</ol>
<h3 id="2-2-3-Code-Example">2.2.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Validate</span><span class="params">(<span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = m;  <span class="comment">// stones to be removed</span></span><br><span class="line">    <span class="type">int</span> st = <span class="number">1</span>;  <span class="comment">// position of the first stone</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> en = <span class="number">2</span>; en &lt;= n; en++) &#123;  <span class="comment">// position of the last stone</span></span><br><span class="line">        <span class="type">int</span> disCur = dis[en] - dis[st];  <span class="comment">// distance between the current stone and the last one</span></span><br><span class="line">        <span class="keyword">while</span> (disCur &lt; d) &#123;  <span class="comment">// If the distance is less than d, we remove a stone</span></span><br><span class="line">            k--;</span><br><span class="line">            en++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// if we have removed too many stones</span></span><br><span class="line">        <span class="keyword">if</span> (en &gt; n) &#123;  <span class="comment">// special case</span></span><br><span class="line">            <span class="keyword">if</span> (st == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// check distance between the first and last stone</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// can move the first stone and keep the condition</span></span><br><span class="line">        &#125;</span><br><span class="line">        disCur = dis[en] - dis[st];  <span class="comment">// update the distance</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF) &#123;</span><br><span class="line">        dis.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dis[i]);</span><br><span class="line">            dis[i] += dis[i - <span class="number">1</span>];  <span class="comment">// compute the prefix sum</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> lb = <span class="number">0</span>, ub = <span class="number">1000</span> * <span class="number">1000</span> + <span class="number">5</span>;  <span class="comment">// upper bound for the maximum distance</span></span><br><span class="line">        <span class="keyword">while</span> (lb &lt; ub) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (lb + ub) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Validate</span>(mid)) lb = mid;  <span class="comment">// update the lower bound</span></span><br><span class="line">            <span class="keyword">else</span> ub = mid - <span class="number">1</span>;  <span class="comment">// update the upper bound</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Design and Analysis</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/02/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start">Quick Start</h2>
<h3 id="Create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
