<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. The main idea of divide and conquer algorithm  The divide-and-conquer strategy algorithm consists of three stages: Divide, Conquer, and Combine. The Divide stage is where the original problem is di">
<meta property="og:type" content="article">
<meta property="og:title" content="üï∂Ô∏è Divide and Conquer">
<meta property="og:url" content="http://example.com/2025/02/24/Divide-and-Conquer-1/index.html">
<meta property="og:site_name" content="Yanran Xie&#39;s Blog">
<meta property="og:description" content="1. The main idea of divide and conquer algorithm  The divide-and-conquer strategy algorithm consists of three stages: Divide, Conquer, and Combine. The Divide stage is where the original problem is di">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="attachment:b59e2c4b-c274-41ac-8fdd-0ace58db63de:image.png">
<meta property="og:image" content="attachment:d7796dee-ca1f-4b98-9cf0-09cb25c433d1:image.png">
<meta property="og:image" content="attachment:0a1d8ab8-7782-43f3-bc49-0c81ebdb0a52:image.png">
<meta property="og:image" content="attachment:4fb313a5-1781-4bc0-94c7-cc60d80d1de7:image.png">
<meta property="og:image" content="attachment:1a8628fe-59b6-48c3-aaab-6bfcdd8f1d29:image.png">
<meta property="article:published_time" content="2025-02-24T10:17:40.000Z">
<meta property="article:modified_time" content="2025-02-24T11:54:19.847Z">
<meta property="article:author" content="Yanran Xie">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="attachment:b59e2c4b-c274-41ac-8fdd-0ace58db63de:image.png">

<link rel="canonical" href="http://example.com/2025/02/24/Divide-and-Conquer-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>üï∂Ô∏è Divide and Conquer | Yanran Xie's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yanran Xie's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/24/Divide-and-Conquer-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yanran Xie">
      <meta itemprop="description" content="cyber trash">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yanran Xie's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          üï∂Ô∏è Divide and Conquer
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-02-24 18:17:40 / Modified: 19:54:19" itemprop="dateCreated datePublished" datetime="2025-02-24T18:17:40+08:00">2025-02-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm-Design-and-Analysis/" itemprop="url" rel="index"><span itemprop="name">Algorithm Design and Analysis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="the-main-idea-of-divide-and-conquer-algorithm">1. The main idea
of divide and conquer algorithm</h1>
<blockquote>
<p>The divide-and-conquer strategy algorithm consists of three stages:
Divide, Conquer, and Combine. The Divide stage is where the original
problem is divided into smaller subproblems. The Conquer stage involves
recursively solving the subproblems. The Combine stage is where the
solutions to the subproblems are combined to form the solution to the
original problem.</p>
</blockquote>
<span id="more"></span>
<h1 id="divide-and-conquer-algorithm-framework">2. divide and conquer
algorithm framework</h1>
<p>The pseudocode for the divide-and-conquer algorithm is as
follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(P):</span><br><span class="line">(<span class="number">1</span>) <span class="keyword">if</span> (|P| &lt;= n0) <span class="built_in">adhoc</span>(P);  <span class="comment">// Base case, solve the problem directly</span></span><br><span class="line">(<span class="number">2</span>) divide P into smaller subinstances P1, P2, ..., Pk;  <span class="comment">// Divide the problem</span></span><br><span class="line">(<span class="number">3</span>) <span class="keyword">for</span> (i = <span class="number">1</span>, i &lt;= k, i++) &#123;</span><br><span class="line">    yi = divide-<span class="keyword">and</span>-<span class="built_in">conquer</span>(Pi);  <span class="comment">// Recursively solve subproblems</span></span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">4</span>) <span class="keyword">return</span> <span class="built_in">merge</span>(y1, ..., yk);  <span class="comment">// Combine the solutions of subproblems</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Base Case</strong> (adhoc(P)): When the size of the problem
is small enough (below a threshold¬† <span
class="math inline">\(n_0\)</span> ), we use a direct approach to solve
it, without further division. This is the termination point for
recursion.</li>
<li><strong>Divide Step</strong>: In this step, the original problem¬†
<span class="math inline">\(P\)</span>¬† is divided into smaller
subproblems¬† <span class="math inline">\(P_1, P_2, ‚Ä¶, P_k\)</span> . The
goal is to make these subproblems small enough so they can be handled
easily.</li>
<li><strong>Merge Step</strong>: After solving the subproblems, their
solutions are merged together to form the solution to the original
problem. This merging process is key to the divide-and-conquer
approach.</li>
<li><strong>Designing the Strategy:</strong> The design of a
divide-and-conquer strategy involves dividing the original problem into
k smaller subproblems. This step is crucial and can be approached with
two principles.
<ul>
<li><strong>Balanced Subproblems</strong>: Ideally, the size of the
subproblems should be balanced, meaning that the problems should be
divided such that each subproblem is roughly the same size.</li>
<li><strong>Independent Subproblems</strong>: The subproblems should be
as independent as possible, meaning that the solutions to the
subproblems should not interfere with each other.</li>
</ul></li>
</ul>
<h1 id="typical-application-examples-of-divide-and-conquer-algorithm">3.
Typical application examples of divide and conquer algorithm</h1>
<h2 id="chessboard-covering-problem">3.1 Chessboard Covering
Problem</h2>
<h3 id="problem-statement">3.1.1 <strong>Problem Statement</strong></h3>
<p>Given an integer k ( 1 k ), the chessboard size is 2^k ^k . The
special square is given by coordinates (x, y) , where 0 x, y . he board
must be fully covered using <strong>L-shaped trominoes</strong>, which
come in <strong>four different orientations</strong> (numbered 1, 2, 3,
and 4 as shown in the image). Each L-tromino consists of three
squares.</p>
<figure>
<img src="attachment:b59e2c4b-c274-41ac-8fdd-0ace58db63de:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p><strong>Input</strong></p>
<ul>
<li>An integer¬† k¬† representing the chessboard size¬† 2^k ^k .</li>
<li>Two integers¬† x, y¬† representing the position of the special
square.</li>
</ul>
<p><strong>Output</strong></p>
<ul>
<li>A¬† 2^k ^k¬† matrix where:</li>
<li>The special square is marked as 0.</li>
<li>Other cells are filled with numbers 1, 2, 3, or 4, indicating which
L-tromino covers them.</li>
<li>The output values are separated by <strong>tab spaces</strong>.</li>
</ul>
<h3 id="algorithm-and-approach">3.1.2 <strong>Algorithm and
Approach</strong></h3>
<figure>
<img src="attachment:d7796dee-ca1f-4b98-9cf0-09cb25c433d1:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:0a1d8ab8-7782-43f3-bc49-0c81ebdb0a52:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure>
<img src="attachment:4fb313a5-1781-4bc0-94c7-cc60d80d1de7:image.png"
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="code-example">3.1.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="comment">// Coordinates of the special square</span></span><br><span class="line"><span class="type">int</span> dr, dc;</span><br><span class="line"><span class="type">int</span> size = <span class="built_in">pow</span>(<span class="number">2</span>, k);</span><br><span class="line"><span class="type">int</span> Board[<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc)</span> &#123; <span class="comment">// Merge function</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> tr, <span class="type">int</span> tc, <span class="type">int</span> dr, <span class="type">int</span> dc, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">2</span>)</span><br><span class="line">		fill(tr, tc, dr, dc); <span class="comment">// Recursion base case</span></span><br><span class="line">	<span class="type">int</span> s = size / <span class="number">2</span>; <span class="comment">// Divide into subproblems</span></span><br><span class="line">	<span class="comment">// Special square is in the top-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line">		ChessBoard(tr, tc, dr, dc, s); <span class="comment">// Recursively process top-left quadrant</span></span><br><span class="line">		ChessBoard(tr, tc + s, tr + s - <span class="number">1</span>, tc + s, s); <span class="comment">// Recursively process top-right quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc, tr + s, tc + s - <span class="number">1</span>, s); <span class="comment">// Recursively process bottom-left quadrant</span></span><br><span class="line">		ChessBoard(tr + s, tc + s, tr + s, tc + s, s); <span class="comment">// Recursively process bottom-right quadrant</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the top-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &lt; tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-left quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &lt; tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Special square is in the bottom-right quadrant</span></span><br><span class="line">	<span class="keyword">if</span> (dr &gt;= tr + s &amp;&amp; dc &gt;= tc + s) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="merge-sort">3.2 Merge Sort</h2>
<h3 id="problem-statement-1">3.2.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-1">3.2.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</li>
<li>Merge: A function merge is used to combine two already sorted
subarrays B_1 and B_2 into a single sorted array B .</li>
</ul>
<h3 id="code-example-1">3.2.3 <strong>Code Example</strong></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = iLow;</span><br><span class="line">	<span class="type">int</span> j = iMid + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> k = iLow;</span><br><span class="line">	<span class="keyword">while</span> ((i &lt;= iMid) &amp;&amp; (j &lt;= iHigh)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			iBuffer[k++] = iDatas[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Copy the remaining elements</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt;= iMid) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt; iMid; ii++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[ii];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++) &#123;</span><br><span class="line">				iBuffer[k++] = iDatas[jj];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123; <span class="comment">// Base case for recursion</span></span><br><span class="line">		<span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>; <span class="comment">// Divide the array</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iLow, iMid); <span class="comment">// Recursive call for left half</span></span><br><span class="line">		mergeSort(iDatas, iBuffer, iMid+<span class="number">1</span>, iHigh); <span class="comment">// Recursive call for right half</span></span><br><span class="line">		merge(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Merge the two halves</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) &#123;</span><br><span class="line">			iDatas[i] = iBuffer[i]; <span class="comment">// Copy sorted elements back to original array</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="quick-sort">3.3 Quick Sort</h2>
<h3 id="problem-statement-2">3.3.1 <strong>Problem
Statement</strong></h3>
<p>classic sort problem</p>
<h3 id="algorithm-and-approach-2">3.3.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li><p>Divide: Split the original array A into two equal parts and one
pivot element</p>
<p><strong>Quick Sort</strong> is a <strong>Divide and Conquer</strong>
algorithm that sorts an array by selecting a <strong>pivot</strong> and
partitioning the array into two subarrays:</p>
<ol type="1">
<li><p><strong>Elements smaller than the pivot</strong> go to the
left.</p></li>
<li><p><strong>Elements greater than the pivot</strong> go to the
right.</p></li>
</ol></li>
<li><p>Conquer: If a subarray contains only one element, it is already
sorted; Otherwise, recursively divide the subarrays further</p></li>
</ul>
<aside>
<p>üí°</p>
<p><strong>Quick Sort does not have a merge step</strong>.</p>
<p>Merge Sort keeps dividing into two segments. Quick Sort keeps
dividing into three segments.</p>
</aside>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th><strong>Sorting Algorithm</strong></th>
<th><strong>Uses Merging?</strong></th>
<th><strong>Key Operation</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Quick Sort</strong></td>
<td>‚ùå <strong>No</strong></td>
<td><strong>Partitioning</strong> (placing smaller elements on the left,
larger on the right)</td>
</tr>
<tr>
<td><strong>Merge Sort</strong></td>
<td>‚úÖ <strong>Yes</strong></td>
<td><strong>Merging</strong> (combining sorted subarrays back
together)</td>
</tr>
</tbody>
</table>
<h3 id="code-example-2">3.3.3 <strong>Code Example</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quick Sort</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; iValue1, <span class="type">int</span>&amp; iValue2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> iTemp = iValue1;</span><br><span class="line">	iValue1 = iValue2;</span><br><span class="line">	iValue2 = iTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = iLow + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> j = iHigh;</span><br><span class="line">	<span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &gt;= iDatas[i]) &amp;&amp; (i &lt;= iHigh)) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> ((iDatas[iLow] &lt;= iDatas[j]) &amp;&amp; (j &gt;= iHigh)) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(iDatas[i], iDatas[j]);</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">swap</span>(iDatas[iLow], iDatas[j]);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (iHigh &gt; iLow) &#123;</span><br><span class="line">		<span class="type">int</span> k = <span class="built_in">partition</span>(iDatas, iLow, iHigh);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, iLow, k - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(iDatas, k + <span class="number">1</span>, iHigh);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="time-complexity-analysis">3.3.4 Time Complexity Analysis</h3>
<ol type="1">
<li><strong>Average-Case/Best-Case Scenario</strong>: The best case
occurs when the pivot always divides the array into two equal or nearly
equal halves, such as when the array is already sorted or the pivot
selection ensures balanced partitions (e.g., the median element).<span
class="math inline">\(O(nlogn)\)</span></li>
<li><strong>Worst-Case Scenario</strong>: The worst case occurs when the
pivot consistently produces highly unbalanced partitions, such as when
the array is already sorted (in ascending or descending order) and the
pivot is the smallest or largest element.<span
class="math inline">\(O(n^2)\)</span></li>
</ol>
<h3 id="quick-sort-improvement">3.3.5 Quick Sort improvement</h3>
<p><strong>QuickSort‚Äôs performance depends on the choice of
pivot.</strong> Randomized QuickSort mitigates this by randomly
selecting the pivot, ensuring a more balanced partition on average and
reducing the likelihood of worst-case scenarios.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">randomizedQuickSort</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iLeft, <span class="type">int</span> iRight)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iRight &gt; iLeft) &#123;</span><br><span class="line">        srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="type">int</span> iAncharIndex = rand() % (iRight - iLeft + <span class="number">1</span>) + iLeft;</span><br><span class="line">        swap(iDatas[iAncharIndex], iDatas[iLeft]);</span><br><span class="line">        <span class="type">int</span> k = partition(iDatas, iLeft, iRight);</span><br><span class="line">        randomizedQuickSort(iDatas, iLeft, k<span class="number">-1</span>); <span class="comment">// Sort the left subarray A1</span></span><br><span class="line">        randomizedQuickSort(iDatas, k+<span class="number">1</span>, iRight); <span class="comment">// Sort the right subarray A3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inversion-pair-problem">3.4 Inversion Pair Problem</h2>
<h3 id="problem-statement-3">3.4.1 <strong>Problem
Statement</strong></h3>
<p>Given an array <strong>A</strong> of <strong>n</strong> distinct
non-negative integers, an <strong>inversion pair</strong> (A[i], A[j])
is defined as a pair where¬† i &lt; j¬† and¬† A[i] &gt; A[j] . The task is
to count the number of such inversion pairs in the array.</p>
<p><strong>Input</strong></p>
<p>Each test case consists of two lines:</p>
<ol type="1">
<li><p>The first line contains an integer¬† n¬† ( 1 n ), representing the
number of elements in the array.</p></li>
<li><p>The second line contains <strong>n</strong> space-separated
integers.</p></li>
<li><p>The last input line is <strong>-1</strong>, indicating the end of
input.</p></li>
</ol>
<p><strong>Output</strong></p>
<p>For each test case, output a single integer in a new line,
representing the total number of inversion pairs in the array.</p>
<h3 id="algorithm-and-approach-3">3.4.2 <strong>Algorithm and
Approach</strong></h3>
<ul>
<li>Divide: Split the original array A into two equal parts</li>
<li>Conquer: If a subarray contains only one element, it don‚Äôt include
the inversion pairs; Otherwise, recursively divide the subarrays
further</li>
<li>Merge: The approach is divided into three main components (C1, C2,
and C3), and the total inversion count C is the sum of these components:
<span class="math inline">\(*C=C_1+C_2+C_3*\)</span>
<ul>
<li>C1: Inversions within the left segment of the array</li>
<li>C2: Inversions within the right segment of the array</li>
<li>C3: Inversions across the two segments</li>
</ul></li>
</ul>
<aside>
<p>üí°</p>
<p>How to compute C3? The key insight is to use the merge process of
merge sort.</p>
</aside>
<figure>
<img src="attachment:1a8628fe-59b6-48c3-aaab-6bfcdd8f1d29:image.png"
alt="easy to understand explanation" />
<figcaption aria-hidden="true">easy to understand
explanation</figcaption>
</figure>
<p>easy to understand explanation</p>
<h3 id="code-example-3">3.4.3 <strong>Code Example</strong></h3>
<p>main:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">reverseOrderPairs</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (iLow == iHigh) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Base case: single element</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iMid = (iLow + iHigh) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">long</span> C1, C2, C3;</span><br><span class="line"></span><br><span class="line">    C1 = reverseOrderPairs(iDatas, iBuffer, iLow, iMid); <span class="comment">// Count inversions in the left segment</span></span><br><span class="line">    C2 = reverseOrderPairs(iDatas, iBuffer, iMid + <span class="number">1</span>, iHigh); <span class="comment">// Count inversions in the right segment</span></span><br><span class="line">    C3 = MergeReverse(iDatas, iBuffer, iLow, iMid, iHigh); <span class="comment">// Count inversions across segments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = iLow; i &lt;= iHigh; i++) <span class="comment">// Copy back the sorted result to the original array</span></span><br><span class="line">        iDatas[i] = iBuffer[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C1 + C2 + C3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>merge step:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge the segments iData[iLow:iMid] and iData[iMid+1:iHigh] into iBuffer[iLow:iHigh],</span></span><br><span class="line"><span class="comment">// and count the number of inversions within the merged segments</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">MergeReverse</span><span class="params">(<span class="type">int</span> iDatas[], <span class="type">int</span> iBuffer[], <span class="type">int</span> iLow, <span class="type">int</span> iMid, <span class="type">int</span> iHigh)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = iLow, j = iMid + <span class="number">1</span>, k = iLow;</span><br><span class="line">    <span class="type">long</span> iCrossPairs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= iMid &amp;&amp; j &lt;= iHigh) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iDatas[i] &lt;= iDatas[j]) &#123;</span><br><span class="line">            iBuffer[k++] = iDatas[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Count inversion pairs: if iDatas[i] &gt; iDatas[j], all remaining elements in the left segment</span></span><br><span class="line">            <span class="comment">// from i to iMid form inversion pairs with iDatas[j]</span></span><br><span class="line">            iCrossPairs += iMid - i + <span class="number">1</span>;</span><br><span class="line">            iBuffer[k++] = iDatas[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt;= iMid) <span class="comment">// Copy remaining elements in the left segment [iLow:iMid]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii = i; ii &lt;= iMid; ii++)</span><br><span class="line">            iBuffer[k++] = iDatas[ii];</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// Copy remaining elements in the right segment [iMid+1:iHigh]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> jj = j; jj &lt;= iHigh; jj++)</span><br><span class="line">            iBuffer[k++] = iDatas[jj];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iCrossPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="binary-search">3.5 Binary Search</h2>
<p>Any given set containing n integers, and n integers have been
arranged in ascending order. Given any integer k, judge whether the
integer is in the set. classic divide and conquer problem(‚ùåmerge
step)</p>

    </div>

    
    
    

      <footer class="post-footer">
            <i class="fa fa-tag"></i>
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"> Algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/02/18/article-1/" rel="prev" title="üëìEnumination">
      <i class="fa fa-chevron-left"></i> üëìEnumination
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/02/24/Divide-and-Conquer-The-closest-pairs-of-points/" rel="next" title="ü•Ω Divide and Conquer(The closest pairs of points)">
      ü•Ω Divide and Conquer(The closest pairs of points) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#the-main-idea-of-divide-and-conquer-algorithm"><span class="nav-number">1.</span> <span class="nav-text">1. The main idea
of divide and conquer algorithm</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#divide-and-conquer-algorithm-framework"><span class="nav-number">2.</span> <span class="nav-text">2. divide and conquer
algorithm framework</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#typical-application-examples-of-divide-and-conquer-algorithm"><span class="nav-number">3.</span> <span class="nav-text">3.
Typical application examples of divide and conquer algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chessboard-covering-problem"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Chessboard Covering
Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-statement"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 Problem Statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#algorithm-and-approach"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 Algorithm and
Approach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code-example"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 Code Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#merge-sort"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Merge Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-statement-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 Problem
Statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#algorithm-and-approach-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 Algorithm and
Approach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code-example-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 Code Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quick-sort"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Quick Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-statement-2"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 Problem
Statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#algorithm-and-approach-2"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 Algorithm and
Approach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code-example-2"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 Code Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#time-complexity-analysis"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 Time Complexity Analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quick-sort-improvement"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 Quick Sort improvement</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inversion-pair-problem"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Inversion Pair Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-statement-3"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 Problem
Statement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#algorithm-and-approach-3"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 Algorithm and
Approach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code-example-3"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 Code Example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binary-search"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 Binary Search</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yanran Xie</p>
  <div class="site-description" itemprop="description">cyber trash</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yanran Xie</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
